CS246 Object Oriented Software Development
Fall 2014
Lecture 1 (September 9 2014)
------------------------------------------

Nomair ("Numer[ical]") Naeem
	Also taught: CS241 'baby compilers course', CS444 'advanced compilers course'
	nanaeem@uwaterloo.ca 'prefer not to get emails for general course-related questions'

Course Breakdown:
	Final Exam - 40% - 2.5 hours
	Midterm - 20% - October 23rd - 4:30-6:20 (typical average 55-65% 'nice wake up call')
	Assignment - 40% - Six of them - A0 already out, worth no marks, prereq for future marks
		A1-A4 - worth 7% each, done individually
		A5 - worth 12%, small-medium sized project in groups of two, partner doesn't have to be in same section (same time frame as typical assignment, ~2 weeks)

		Two due dates - end of first week, end of second week
		Using Marmoset
		ISA: Kristen Bradley
		Tutorials: 'not compulsory, but encouraged', none in first week
		Lab hours in week 1: help for a0, MC 2062/2063, email cs246@uwaterloo.ca for help, 10-12, 2-3
		Piazza: monitor daily, check for already answered questions
		Reference materials: textbook not required, no course notes
		Academic integrity: 'do not cheat', 0% on assignment and -5% on course mark
		Welcome to second year: assignments get more difficult, longer description, less spoon-feeding, READ QUESTIONS MULTIPLE TIMES, no solutions provided

	You must use a *nix environment or SSH+WinSCP or Cygwin
	Use the cs136 virtual box (works fine until a3), not recommended
	MANAGE YOUR TIME

4 MODULES
	1 - Introduction to Unix Shell (2-3 weeks)
	2 - C++ 03 'Object Oriented Software Development' (10 weeks)
	3 - Tools
	4 - Software Engineering Principals

Module 1: Linux Shell
	interactive environment  - an interface to the Operating System
	Shell: how we get the OS to do "things" for us.
	Two kinds of shells:
		- Graphical
		- Text-based (command line)

	1. Graphical (eg. Windows, OSX, Gnome, KDE)
		+ Intuitive to use
		+ Mouse clicks
		+ Drag and drop
		- harder (difficult) to do less common tasks (eg. batch-renaming of files ending in cpp to cc)

	2. Command Line Shell
		Interface to unix/linux environment
		Even Windows has a command-line shell (DOS)
		+ Much more powerful
		- Must learn basic commands (steep learning curve)

	History of UNIX Shell:
		Linux has its roots in the original unix OS (70s)
			- The original unix had a command line shell ("Shell", "BourneShell" to differentiate)
			- Written by Stephen Bourne
		Other Shells:
			- CShell (csh)
			- KornShell (ksh)
		These shells also evolved
			- csh became tcsh
			- BourneShell became BourneAgainShell (BASH)
		Command: echo $0
			> 'bash' ($>) or 'tcsh' (%>)

	Linux File System
		- Contains files
			- files (data/programs) 'ordinary files'
			- directory (can contain other files) 'just like folders in Windows'
			/
				bin/
					bash/
					ls/
					cd/
				etc/		(configuration files)
					shells
				home/
					nanaeem/
						cs241/
						cs246/
				usr/		
					bin/	(user programs)
					include/	(C headers are located)
		- Root of the tree structure is a dir called '/'
		- Can have two files with identical names as long as they are in different directories
		- We can specify any file by giving its path
		- '/bin' means 'bin' directory inside '/' directory
		- '/user/bin' - bin directory inside the 'usr' directory inside the '/' directory
		- Current Directory:
			- The directory we are currently in
			- Command 'pwd' (present working directory) outputs current directory
---------------------------------------------------------
Lecture 2

Directories start from root '/', these are absolute paths
Relative paths start from the current directory
	If current dir is '/home/nanaeem/cs246', then the file (remember, directories
	are actually files) 'Fall/a0' is the same as '/home/nanaeem/cs246/Fall/a0'.
	The advantage of relative paths is that it reduces typing.

Four different special directories:
	1. '.' - refers to current directory
		eg. '$> cd .'  does nothing
	2. '..' - refers to the parent directory
		eg. '$> cd ..' changes pwd to parent directory
		If you want to get to the grandparent, '$> cd ../..'
	3. '~' (Tilde) refers to the home directory
		'$> cd ~' changes to home directory
		Shortcut: '$> cd'
		Can continue path '~/cs246/Spring'
	4. '~userid' - userid's home directory (useful for sharing files between unix accounts)
		eg. '$> cd ~nanaeem'

To see the contents of a directory use 'ls' command (listing).
	- Shows files in your current directory
	- Does not show hidden files (starting with '.', icluding special dirs './' and '../') by default
	- 'ls -a' shows all files

In unix, there is no concept of file extensions (like .txt), although conventions are often enforced.

Wildcard Matching
		List all files ending with '.txt':
				'$> ls *.txt'
					   ^^^^^ globbing pattern
					   ^     match anything
					    ^^^^ that ends with '.txt'
				'globbing' comes from a legacy Glob program that performed wildcard searches
				The shell finds all the files that match the globbing pattern, and replaces the globbing pattern with those files.
				'ls *.txt' --> 'ls sample.txt t1.txt t2.txt'
				The shell is doing the hard work here.

				Behaves the same here as 'echo *.txt'
'$> rm' removes (permanently) the specified file(s)
	- University pays $45k a year with snapshot
	- 'Google version control'

'$> echo' parrots whatever the input is.
	'$> echo '*.txt'' outputs *.txt
	Single quotes and double quotes behave the same here.
	Do a 'man ls'.

CTRL-C to kill execution of curent program.
CTRL-D sends EOF. (Useful for telling cat to stop listening to stdin and clean up execution)
Working with files
	'$> cat' (concatenate)
		Show or display contents of a file.
		Simply typing 'cat' will hang the program until text is input.
		'cat > output.txt' output redirection
		If output.txt exists already, it will be overwritten.
		After pressing Enter, the line is written to the file.

	In general: 'command args > filename' puts any output into file
	This is called output redirection.

	Input redirection: 'cat < sample.txt', which is equivalent to 'cat sample.txt' here. But with redirection, the shell is opening the file instead of cat.
		If file contains another filename, it only prints the filename.

	'$> wc filename' wordcount
	'wc sample.txt' outputs filename because wc opens the file, but with 'wc < sample.txt', wc doesn't know the filename
	'cat < output.txt > myfile.txt'
	Note that shell commands will create the file if it doesn't exist, or overwrite the file if it does!

Every process is attached to three streams:
						  /--- stderror (standard error)
	stdinput --- [program]
						  \--- stdout (standard output)

	stdin - Where the input comes from (default: the keyboard).
	stdout - Where the output goes (default: screen). This is buffered, and flushed periodically.
	stderr - Where the errors go (default: screen). Seen immediately, one character at a time (never buffered).

	Input redirection changes stdin from keyboard to files (or socket from the internet, etc.)
	$> myprogram < in.txt > out.txt 2> error.log
		'2>' handles stderr stream

What if you want to append to a file? Go to the tutorial.

Pipes ('|')

						  			  /--- stderror2
	stdout1 | stdinput2 --- [program2]
						  			  \--- stdout2

	Pipe output of process 1 into process 2.
	'$> process1 | process2'
	(| is also bitwise OR in C)

	Example 1: How many words occur in the first twenty lines of sample.txt?
	'$> head -20 sample.txt | wc -w' --> 165

	Example 2: Suppose files w1.txt and w2.txt contain lists of words, one per line. Print a duplicate-free list of all words.
	uniq - checks for duplicates that are adjacent, so we must sort first.
	sort - sorts
	'$> cat w1.txt w2.txt | sort | uniq'
-----------------------------------
Lecture 3

Pipes
	last class:
		head -20 sample.txt | wc -w

	Equivalent to:

		head -20 sample.txt > temp.txt
		wc -w temp.txt

	The benefit of using pipes is to prevent using time/memory to write output to the disk.

How to pass the output of a program as an argument to another program.
	e.g. $ echo Today is date and I am whoami
	--> Today is date and I am whoami

	Put command in back-quotes (under tilde): Today is `date` and I am `whoami`
		7 words act like 7 arguments passed to echo.
	Also valid: echo "Today is `date`" (shell can execute commands in double quotes)
				echo Today is $(date)  (this syntax has the advantage of nesting without messy escaping)

Pattern Matching Inside Files
	Tool: grep (Global Regular Expression Pattern) (outdated)
		  egrep (Extended '''), equivalent to grep -E

		Usage: $ egrep pattern file
		Output: lines in file that match the pattern

		e.g. Find all occurences of cs246 in index.shtml
		  	$ egrep cs246 index.shtml
		  	--> All lines of html containing substring "cs246"
		
		Find occurences of 'CS246' or 'cs246'
		Student: {CS,cs}, egrep -e?
		OR '|': egrep cs246|CS246 index.shtml --> bash interprets this as a pipe!
			Use quotes: egrep 'cs246|CS246' index.shtml
			Or, alternatively:
			egrep "(CS|cs)246" index.shtml
			egrep "(c|C)(s|S)246"

Use Regular Expressions
	e.g. lines that contained cs246 OR CS246
		"cs246|CS246"
		===
		"(cs|CS)246"
		!==
		"(c|C)(s|S)246"

	a|b|c|d (a or b or c or d)
	Instead, use square brackets: [abcd]
		This chooses one character from this set.
	Ranges: [0-9]
		This chooses one digit from 0 to 9.

	All characters except certain characters: [^abcd]
		Any one character *except* a character from this set.

	e.g. What if we want an optional space between cs and 246?
		'?' is used to indicate 0 or 1 of the preceeding expression.
			$ egrep "cs( )?246" index.shtml
				Equivalent to: "cs ?246" without parenthesis, the preceeding expression/character is used (but brackets are encouraged)

	'*' is used to indicate 0 or more of the preceeding expression.
		e.g. egrep "(cs)*246" index.shtml
			--> 'cs246', '246', 'cscs246', 'cscscs246', ...
		If one line is matched it gets printed regardless of multiple matching cases.
		Cases regarding smallest/biggest matches, 'greedy' matching algorithms (largest match) are discussed in cs240.

	How do you find a '*' or a '?'?
		Escape it using '\'.
		e.g. "cs\?246"
			This escapes the special symbols (anything that has meaning within a regex)

		Remember - "Am I writing a globbing pattern or a regex?"
			Globbing pattern: '*' matches anything
			Regex: match 0 or more

	Dot ('.') matches any one symbol.
		e.g. egrep "cs.*246" index.shtml
			This matches ~~~cs~~~~~~246~~~, e.g. 'FOOcs246BAR'

	Carat ('^') (outside brackets) matches patterns at the beginning of the line.
		e.g. "^cs246"
			This gives all lines that start with cs246.

	Dollar ('$') matches ending characters.
		e.g. egrep "cs246$"
			This gives all lines that start with cs246.
		e.g. egrep "^cs246$"
			This gives all lines that contain exactly this string.

	Plus ('+') matches one or more of the preceeding expression.
		e.g. egrep ".+" index.shtml
			This prints all non-empty lines.

	*Note that there is a difference tbd between single and double quotes.

Useful egrep switches:
	Print all words of even length from /usr/share/dict/words
		Incorrect: $ egrep "(..)+" /usr/share/dict/words
			This returns all lines, since this isn't starting at the beginning of the line. All even substrings get found!
		Correct: $ egrep "^(..)+$" /usr/share/dict/words

	*Don't forget ^$ on the assigment!

	Print all files in the current directory whose name contain exactly one 'a'.
		$ ls | egrep "^[^a]*a[^a]*$"

	Print all words in /usr/share/dict/words that starts with an e and has length 5.
		$ egrep "^e....$" /usr/share/dict/words

----------
$ egrep -i
	This ignores case

$ egrep ./*
	Globs all files in directory.

$ egrep -R
----------

File Permissions
	$ ls -l
		Long listing that gives additional information on each file.
			Contains permissions strings!
		-rw-r--r-- 1 nanaeem staff 10K [Date Modified] [Filename]
				   ^ indicates number of symbolic links to this file
				   	 if this is a directory, indicates number of files within + number of sym links to the dir
				   	 'all references to this file'
				     ^^^^^^^ owner
				     		 ^^^^^ group
				     		 	   ^^^ size
			'-' indicates ordinary file
			'd' indicates directory
			'l' indicates symbolic link (shortcuts)

	Group: way to share files in linux.
		A linux user can belong to many groups.
		A file can belong to one group.

		Permission: 3 groups of 3 bits
			User bits, group bits, other bits
			r -> read or set to '-'.
				File: read (cat, etc.). Directory: read contents of directory (ls, etc.).
			w -> write or set to '-'.
				File: write (vi, etc.). Directroy: modify contents (add/remove files, etc.).
			x -> execute or set to '-'.
				File: treat a file as a program and try to run it. Directory: you can enter that directory (cd, etc.).
			All On: rwxrwxrwx
			All Off: ---------
			Read, write, execute
		e.g. -rw-r--r-x
			Owners (user) can read and write, group can read, others can read and execute.
		chmod
-----------------------------------------------------------------------
Lecture 4

File Permissions:
	The owner of a file is the only one who can change file permissions
		You can't grant the permission for other users (non-owners) to change permission
	$ chmod [mode] [file]
		changes permissions
		Mode:
			ownership class:
				u = user
				g = group
				o = others
				a = all
			operator:
				+ add permission
				- remove permission
				= set exactly
			permission:
				r read
				w write
				x execute

	e.g. Give others read permission
		chmod o+r file.txt 		*Implicitly removed pre-existing permission

	You can specify mode with 3-digit numbers (you don't have to know this)

	e.g. Revoke execute permission from group
		chmod g-x file.txt

	e.g. Make everyone's permission exactly rx
		chmod a=rx *.cc 	*If it was a+rx, a pre-existing w permission wouldn't be overwritten

	e.g. Change owner's permissions
		chmod u-rwx *.* 		*You always have permissions. You can always re-give yourself permissions.

Scripting
	e.g. $ x=1			*No spaces, or else it'll try to execute a program
		 $ echo $x

		 To set a variable do not use $
		 To access the value of a variable use $ and {}
		 	e.g. ${x}
		 The value of a variable is always a string
		 	e.g. x=1 		*1 is the string '1'

	Some variables are global:
		Path - variable
			Colon-separated list of linux paths.
			Used for ls as ls is not built in. Shell looks in all directories specified in path.
			*Do not overwrite path

	.bashrc (how to set variables that stay)

	A script is a file containing a sequence of linux commands which we can execute as a program.
	e.g. Print the date, current user, and current directory.
		./basic:

		#!/bin/bash   			"hash, bang; shebang line"
		date
		whoami
		pwd

	Command line arguments to a script:
		inside the script:
			$1 first arg
			$2 second arg
			.
			.
			.
			$n nth arg

		e.g. Check whether the input word is in the dictionary.
			#!/bin/bash
			egrep "^$1$" /usr/share/dict/wprds
			Right now, if $1 is a word, $1 will be printed. Else, nothing is printed.

		e.g. A good password is not a word in the dictionary. Answer whether the password is good.
			#!/bin/bash
			egrep "^$1$" /usr/share/dict/words > /dev/null  	"black hole used to discard input"
			if [ $? -eq 0 ]; then
				echo "Not good password."
			else echo "Maybe not a good password."
			fi  		"This closes the if statement."

			*-ne Not Equal
			*-lt Less Than

		'if' is running a program called '['
			Anything after '[' are arguments.
			'[' evaluates condition, sets status code
			'if' checks the status code

		Look at:
			goodpassword check  *${#} contains the number of arguments to the script
			goodpassword usage () { }    *A function.

	General format for an if statement:
		if [ condition ]; then
			# Block of code.
		elif [ condition ]; then
			# Block of code.
		else # Line of code.

		"Look at rename c and count words for loops"
-------------------------------------------------------
Lecture 5

Loops
	e.g. Print all numbers from 1 to $1 ($1 is the first argument to our script)
	#!/bin/bash
	# count limit ---counts the numbers from 1 to limit
	usage () {
		echo: "Usage: $0 limit" 1>&2
		echo " where limit is at least 1" 1>&2
		exit 1
	}

	if [ $# -ne 1 ]; then
		usage
	fi

	if [ $1 -lt 1 ]; then
		usage
	fi

	x=1
	while [ $x -le $1 ]; done			# 'le' less than or equal
		echo $x
		x=$((x+1))			# "$x+1" would do string concatenation
	done

For Loop
e.g. Rename all .cpp files to .c 	# scripts/RenameC
#!/bin/bash
for name in *.cpp; do
	mv ${name} ${name%cpp}cc
done

Here, the shell replaces *.cpp with a space delimited list of filenames. (a1.cpp a2.cpp ...) (globbing pattern gets replaced just before the loop's execution starts)

e.g. How many times does word($1) occur in the file($2)
#!/bin/bash
x=0
for word in `cat "$2"`; do 			# 'for word in cat $2' (without backquotes) will get the word 'cat' then the filename 
									# GOTCHA: put double quotes around command arguments (without, strings with spaces are treated as multiple objsects, such as "hello word")
	if [ $word = $! ]; then 		# '=' is used for string equality (strings on both sides) or for arithmatic (integer values)
		x=$((x+1))
	fi
echo $x
done

Payday is the last Friday of the month.
What date is this month's payday?
$ cal | awk '{print $6}' | egrep [0-9] | tail -1
/cs246/1149/lectures/shell/scripts/paydayThisMonth
# elif [ $1 -eq 22 ]; then
#	echo "on the ${1}nd"


Testing
	In this course, you will be expected to formally test your code before submitting.
	- Use the script we ask you to write in a1 (runsuite)
	Each assignment has 2 deadlines
		Due date 1: test suites
			Run on a correct program (public)
			Release tests are buggy programs that we created. "The test suite that you created should be thorough enough to catch all of our bugs."
		Due date 2: code
	Testing tips:
		negative/positive values
		edge cases [0-10] check 0 and 10
		corner cases (multiple simultaneous boundaries)
	This is black box testing (we do not see the implementation)
	White box: full access to implementation
	Grey box testing: some limited acces to control flow of the program

	*Read through assignment very carefully
	*Think carefully about what the edge/corner cases are, etc. (max X, max Y)

Module 2: C++
Bjarne Stroustrup in the 80s
	Worked at AT+T labs (same place where UNIX and C were invented)
	Colleagues were inventors of C, UNIX
	Playing with the language called Simula67 (considered the first OOP language)
	Came up with 'C with Classes'
C++ is too big to cover in one course.
We will introduce the core concepts.
We will focus on C++03, which is reasonably sized
	New version is C++11, which has sme very sophisticated new concepts.
	UW's CSCF/MFCF still don't support C++11

hello.cc:
--------------------------------------
#include <iostream>
using namespace std;

int main() {
	cout << "Hello World" << endl;
	return 0;  						  // return statement must be explicitly defined in c++
}
--------------------------------------

Output in C:
#include stdio
printf('Hello World')

stdio/printf is available in c++, but DON'T USE IT!

Preferred c++ I/O
	#include <iostream> 	(no .h)
	std::cout << data1 << data2;
	std::endl;  		// newline (\n)

Using G++ compiler
Compile:
	$ g++ hello.cc
	Creates an executable called a.out (default name)
	$ g++ hello.cc -o myprog
	Creates an executable called myprog

	Execute with $ ./a.out, $ ./myprog
----------------------------------
Lecture 6

Clarification: Arguments vs. Input
	$ prog a1 a2
		"Two arguments. We're assuming the program knows how to handle this. The program can still read input from stdin, things you type." -NN
	$ prog a1 a2 < file.txt
		"Whenever you want to read input, read from the file. Faucet of data is just waiting there." -NN
	"I would highly recommend looking at diff, and what status codes it sets. Diff will set ${?} to 0 if different and 1 if not the same."

Recall:
	cout << stuff << endl; 		// endl is optional, it just adds a new line
	C++ provides three I/O stream objects
		cout: print to stdout
		cin: reads from stdin
		cerr: prints to stderr

I/O Operators
	<<: output operator, "put to" operator
	>>: input operator, "get from" operator

	e.g.
		cout << x; // put x to stdout
		cin >> y; // get from stdin into y
		cerr << z; // put z to stderr

		"The arrow is in the direction of information flow."

intro/plus.cc (Reads 2 numbers and adds them.):

	#include <iostream>
	using namespace std;
	// Won't write the above two lines any more.

	int main () {
		int x, y; // two int vars
		cin >> x >> y;
		cout << x + y << endl;
	}

	// Whitespace delimits strings from stdin. "./plus" then "4 5" is sufficient.
	// ./plus, 4 five --> 4
	//		y is not necessarily set to zero, it is a garbage stack location

	cin is waiting for input, ignoring whitespace.
	If a read fails, the program will move on! This is troubling.
		Scary that there is no indication of failed read.
		If a read fils then cin.fail() is true.
		If a read fails due to end of input then both cin.fail() and cin.eof() are true.

e.g. Read all integers from stdin and print them, one per line, on stdout. Stop if a non-integer or EOF is encountered.
lectures/io/readInts.cc

int main () {
	int i;
	while (true) {
		cin >> i;
		if (cin.fail()) break;
		// come here only if read is successful
		cout << i << endl;
	}
}

./a.out:
3
3
4
1 2 3 4
5
2
five
^ program terminates here when these characters are encountered.

CTRL-D or CTRL-C will also terminate. cin.fail() and cin.eof() flags will both be raised if we do that.

There is an implicit conversion from cin to void*. "A pointer with no type, or a pointer that can point to anything."
	"cin is a stream object of type istream"
	void* is a pointer to anything. It's key here that we can treat something as a pointer.
	A pointer is a numeric quantity
	if (cin) // true if !cin.fail(), false otherwise

	Now we can do "if (!cin) break;"

We have said that >> is the input operator.
In C/C++, >> is the right bit shift operator;
	a>>3; // 10101 >> 3 = 00010 (21 -> 2) (divides by 2^3)
These operators are overloaded.
	a>>3; vs cin>>y; have different meanings.
	Compiler checks left hand side
	LHS: int
		treats >> as bit shift operator
		result: int
	LHS: istream
		treats >> as input operator
		result: cin (an istream)
		This is useful for using multiple operators in series.
			cin >> x >> y
			Here, "cin >> x" results in a cin object (and in x having a value)
				This becomes "cin >> y", which results in cin; which ends.
		This is called casdading.
			We've already taken advantage of this, e.g. "cout << i << endl"
		You can cascade as many times as you want.
			cin >> x >> y >> z >> a;
				If cin fails early on, all subsequent reads fail.
	We can combine 2 lines in readInts.cc:
	if (!(cin >> i)) break; // "cin >> i" mutates i and evaluates to cin, which evaluates to binary based on whether the read was successful.

Rewriting readInts.cc (readInts4.cc):

int main () {
	int i;
	while (cin >> i) {  // Works if we only care about reads failing. Does not check for EOF. BE ABLE TO EXPLAIN THIS ON THE MIDTERM! (produces cin, converts to void*)
		cout << i << endl;
	}
}

e.g. Read all ints and echo them to stdout. Skip non-integers. Terminate at EOF.
	(Can't use simplified code above, since we need to distinguish _why_ the read fails.)

int main () {
	int i;
	while (true) {
		if (!(cin >> i)) { // something failed, this is the fail block
			if (cin.eof()) break; //done
			else { // bad read (received a non-integer)
				// for non-integer reads, we could:
				//		a) do nothing (but this will loop infinitely, because the fail flag will still be raised (cin.fail() is true)! )
				// 			recall: "once a read fails, all subsequent reads fail"
				// 		b) clear the flag: cin.clear();
				// 			if we only do this, we loop forever because that bad input is still there, even though the fail flag is cleared
				// 		c) ignore the bad input: cin.ignore();
				// 			This works! :)
				cin.clear();
				cin.ignore();
				// (!(cin >> i)) continues successfully now.
			}
		} else {
			cout << i << endl;
		}
	}
}

"You will be tested on these technical details on the midterm." -NN
Look at http://stackoverflow.com/a/6791854  -JR
---------------------------------------------------------------
I missed lecture 7.
The following is transcribed from Anna Lorimer's written notes.
---------------------------------------------------------------
Lecture 7

Streams

C++ Provides a string type: std::string
	Available in io/readstrings:


	#include <iostream>
	#include <string>

	int main () {
		string s; // you only have to change the type
		cin >> s;
		cout << s << endl;
	}


	*cin reads until whitespace

If you want to read in an entire line, use getline:
	getline(cin, s); // s is a string variable
		This reads until newline

In C you would use scanf with format specifiers.
	You don't need format specifiers in C++ (%s string, etc.)

How would you format cout? I/O Manipulators.
	e.g. cout << hex << i;
		hex is an i/o manipulator that prints i in hexadecimal
		This works by sending hex to cout. Nothing is printed but it changes how cout behaves by telling cout to set itself to hexadecimal.
		You have to reset cout after if you no longer want hex.
			e.g. cout << dec; // changes hex to decimal

There are lots of I/O manipulators:
	Look at <iomanip> header
	e.g. Left and right precisions (justifications)
		cout.width(20);
		cout << left << "Left alligned!" << endl;
		cout << right << "Right alligned!" << endl;

Stream abstraction works for other sources of data.
	How to read from a file:

	#include <fstream>  // gives you access to ifstream (read) and ofstream (write)
	#include <iostream>
	using namespace std;

	int main () {
		ifstream f("suite.txt"); // here "ifstream" is the type, "f" is the name of the variable (*cough*OBJECT*cough* -JR), and "suite.txt" is the initialization.
		string s;
		while (f >> s) {  // while read is successful
			cout << s << endl;
		}
	}

	Anything you can do with cin (i.e. istream), you can do with a variable (f) of type istream.
		Same for cout and ofstream.

	You can treat a string as the source of input (input string).
	You can also write to a string.
		Include <sstream> which gives you istringstream (input) and ostringstream (output)

	Example: buildstring.cc

	
	int low = ...;  // constant string
	int high = ...;
	ostringstream ss;
	ss << "Enter a number between" << low << "and" << high << endl
	string s = ss.str(); // extract a string out of ostringstream
	cout << s;


	This is useful for converting a string to a number.

	getnum.cc:

	#include <iostream>
	#include <string>
	#include <sstream>
	using namespace std;

	int main () {
		int n;
		while (true) {
			string s;
			cout << "Enter a number:" << endl;
			cin >> s;
			istringstream ss(s);
			if (ss >> n) break;  // read int from ss

			cout << "That's not a number! Try again:" << endl;
		}
		cout << "You entered " << n << endl;
	}


	Look at readints5.cc and readintsSS.c, they do the same thing.

	*The only time reading in a string fails is EOF.

Strings
	In C we don't have strings, we have NULL-terminated character arrays.
		This is annoying, namely the fixed size thing.
		You might accidentally overwrite the null terminator.
	C++ also has no built in strings, but provides string type.
		This grows and shrinks as needed.

		Example: string s = "Hello"; // type of s is stdstring, type of "Hello" is a C-style string (i.e. a character array that is NULL-terminated)
		*You're assigning a C-style string to a C++ string -> should give a compiler error!
		C++ has a special feature which converts a C-style string to a C++ string (they are NOT the same).

---------------- In C ---- vs. -- In C++ ---
Equality      | strcmp()      | s1 == s2
              |               |
Inequality    | strcmp()      | s1 != s2
              |               |
Comparisons   | strcmp()      | <, >, ==
              |               |
Length        | strlen()      | s.length()
              |               |
Concatenation | strcat()      | s = s1 + s2
--------------------------------------------

In C you can directly access individual characters in a string.
	You can still do this in C++ (individual access)
	This is done with overloading square brackets [].
	Example:
		std::strings = ...;
		s[0], s[1], ... are accessible
----------------------------------------------------------
Lecture 8

Assorted Goodies
Default Arguments
	void printSuiteFile(string filename = "mytests.txt") {
		ifstream myfile(filename.c_str()); // ifstream arg must be a 'C-style string', not string object. (won't compile if only calling with 'filename')
		string s;
		while (myfile >> s) {
			cout << s << endl;
		}
	}

You can get a c style string from std::string using the following:
	filename.c_str();

printSuiteFile(); // use the default value
printSuiteFile("suite.txt"); // use the specified arg

Optional arguments must appear last!
A default argument cannot be followed by a non-default argument.

void testParams(int num=0, string city="Waterloo")

testParams(5, "Toronto"); // legal
testParams(5); // legal
testParams(); // legal
testParams("Montreal"); // not legal
testParams( , "Montreal"); // not legal
*Can't assign city="Montreal" while calling, as in Python

Overloading (Function Overloading)
------------------------------------
int negate (int a) {
	return -a;
}
bool negate (bool a) {
	return !a;
}
-----------------------// in c, this won't compile! Functions must have a unique name.

In C++, this works. We have overloaded the negate function.
The C++ compiler looks at the name of the function, number of arguments, and types of arguments.
"What identifies a function is not only its name, but its argument types."

Function Header (Signature)
	In C++: name + types of arguments

In C++, you cannot have two functions that only differ in their return type.

Recall: '<<' operator
	Actually implemented in C++ as a function:
		____ operator<<( , ) { ... }
		int operator<<(int, int) { ... } // returns int
		istream operator<<(istream, int) { ... } // returns istream "not exactly correct, but we'll get to why soon"
		ostream operator<<(ostream, string) { ... } // returns ostream
		"Perfect example of overloading in C++"
		"Compiler will keep a list of the different function headers"
		"Well documented in <iostream> stdlib"

Declaration Before Use
	In C, we cannot use something before it's declared.
	Same in C++.
		This is problematic for mutual recursion (where two functions are calling each other).

	Look at:
	functions/forwardBad.cc
		Won't compile, because "odd was not declared in this scope".
		To fix this, forward-declare the odd function (header only).
	functions/forwardGood.cc
		bool odd(unsigned int n); // forward declaration (doesn't define the function, but says that it exists).

	forwardBad.cc does not compile because odd is used before it is declared.
	To avoid this, add a forward declaration for odd.
	Saying to the compiler: 'Trust me, you will see a function with this signature.'
		*You can place default arguments in forward declarations.

	Declaration before use, NOT definition before use.
		A declaration is simply an assertion that something exists.
		A definition is the actual implementation.
		*You can declare something as many times as you want, but you can define it only once.
			(There is no benefit to doing multiple declarations, this is just a technicality)

Pointers
	int n = 5;
	int *p = &n; // p is set to the address of n
	cout << p; // prints 10000 (in hex)
	cout << *p; // prints the contents of the thing p points to

	int **pp; // declare a pointer to a pointer to an int
	pp = &p; // 48000
	**pp = 10; // dereferences address 48000 and then 10000. 5 mutates to 10.
		*if(pp) is only false if it doesn't point to an address, is 0 or NULL
__________________
|ADDRESS | STACK |
-----------------|
|        |       |
|10000  n| 5     |
|        |       |
|        |       |
|        |       |
|48000  p| 10000 |
|        |       |
|        |       |
|        |       |
|      pp| 48000 |
|        |       |
|        |       | 
------------------

Arrays
	int a[] = { 1, 2, 4, 8 };
	An array is not a pointer!
	The name of the array is shorthand for the address of the first element of the array.
	a == &a[0]
	*a == a[0]
	*(a + 1) == a[1] // '+' operator accounts for size of typeof(a)
		Recall that this is called "pointer arithmetic"

Structs
	In C:
	struct Node {
		int data;
		struct Node * next; // You don't need to write 'struct' here in C++ (leaving it in is okay, because backwards compatible)
	}; // Don't forget the semicolon! You can technically declare global variables of Node (n1, n2, etc.) before the semicolon, so it is needed!

	In C++:
	struct Node {
		int data;
		Node next;
	}; // Won't compile. ("Can I determine the size of this node in order to allocate memory? Nope. Four bytes plus size of a Node...")
	This worked before, because pointers had a fixed size.

Constants
	const int maxGrade = 100; // Told the compiler that maxGrade has value 100 and it won't change.

	Rule: a const definition must be initialized (can't just say 'const int maxGrade;') "Must be defined when you declare it."

	Constants of other types can also be defined:
	const Node n = {5, NULL}
		Cannot change n. n.data = 10; // Won't work.

	int n = 5;
	const int *p = &n; // p is a pointer to a constant int. [a const-int, haha -JR]
	*I can change p if I want. p=&m; // p is not a constant pointer
	*I cannot, however, use p to change n. *p = 7; // Won't work.
	*I can still directly change n. n = 10; // Works.
	Read backwards: "p is a pointer to an int constant"
	
	int * cons p = &n;
	"p is a constant pointer to an integer"
	*Now, I can't do p = &m;
	*Can do *p = 20;

	const int * const p = &n;
	*Can't do p = &m;
	*Can't do *p = 10;
	*Can still change n directly if it wasn't declared as constant.

Parameter Passing "5-10% QUESTION ON MIDTERM!" -NN
	void increment(int n) {
		n+=1;
	}
	int x=5;
	increment(x);
	cout << x; // prints 5

	Pass by value: a copy of x was created!

	void increment(int *n) {
		*n += 1;
	}
	int x=5;
	increment(&x); // send the address of x
	cout << x; // prints 6.

	*Note that these also count as overloaded functions.

Cliffhanger for next time:
	scanf("%d", &i); // read an int into variable i
	We gave the address of i.
	cin >> i; // reads in a value at i
	These functions are operators (operator>>(istream, int))
	Why can I pass it i, not &i?
	Why not do cin >> (&i); // ?

	"Pass by reference!" -NN
----------------------------------
Lecture 9

Recall cliffhanger from last time:
	scanf("%d", &i);
	cin >> i; // why does this work? (It's not being sent the address of the variable, just the name of the variable)
	Why not use "cin >> (&i);" ?

C++ provides another pointer-like type: References
	int y = 10;
	int &z = y; // z is a reference to y (in C++). Do NOT read this as "the address of z equals y", say "z is a reference to y".

	A reference is like a constant pointer with automatic dereferencing.
		z will always point to y.
		We can write: z = 15; // changes the value of y
			This sets y to 15.
			We no longer have to do *z = 15; // illegal in C++
			No star is needed because it will ALWAYS be automatically dereferenced.

	int *p = &z; // sets p to the address of y
		We set p to the address of z, but since z is a reference to y, we got the address of y.
		A reference has no identity of its own. We tried to assign it a value or get its address, but got y each time.
			It is another name for y.
			Or we can say z is an alias for y.
		Even doing sizeof(z) doesn't always return 4 bytes as expected in C, but the size of y.

	Rules of references:
		1. We cannot leave references uninitialized.
			int &x; // can't do this, since constants/references must be initialized

		2. A reference must be initialized to something that has an address.
			Things that have an address are called 'Lvalues' (this is a compiler term).
			int &x = 5; // can't do this, because 5 is not really an address but a literal value.
			int &y = a + b; // can't do this either, because an expression doesn't technically have an address.

		3. We cannot create a pointer to a reference.
			int &*x = ...; // doesn't work (at least not in the g++ standard)

			3a. We can, however, create a reference to a pointer.
				int *&x = ...; // works

		4. We cannot create a reference to a reference.
			int &&x = ...; // not allowed

			Note: we can still do *p = &z; // sets p to the address of what z is referencing

		5. We cannot create an array of references.
			int &x[3] = {1, 2, 3}; // not allowed
				The name of an array is a pointer to the first address of the array, but &*a is disallowed.

	Use references in function parameters.
		Recall this code from last class:
			void inc (int *n) {
				*n += 1;
			}
			int x = 5;
			inc(&x);
			cout << x; // 6

		Now we will do this with references:
			void inc(int &n) {
				n += 1;
			}
			int x = 5;
			inc(x);
			cout << x; // 6

			In this code, x is being passed by reference. Anything we do to n is actually being done to x.

		Note: We could have a reference to a function (like how we can have a constant pointer to a function).

	Why does "cin >> x" work?
		x is passed as a reference.

		Let's look at the function header for the input operator:
			istream &operator>>(istream &in, int &data) {
				// type of cin is a reference to an istream.
				// "int &data" is the right hand side, it takes the argument by reference.
				// "istream &in", the left hand side, is also being passed by reference. This is so that we can set error flags on "&in" (cin)
				// the reasoning for the return value of "istream &" is so that we aren't returning a copy istream, but rather a reference to the original istream (so it can be chained into another expression)
				// in C, we would have to do all of this with pointers. Automatic dereferencing is the main advantage here.
			}

Suppose I have a struct:
	struct ReallyBig {
		...;
	};
	int f (ReallyBig rb) { ... }
	f(x); // what happens here?

	A copy of x is going to be made.
		(-) This is expensive to do.
		(-) Also, the changes to rb are not visible to the caller (the piece of code that called f)

	In C, we would send a pointer to ReallyBig.
		(+) This suppresses the copy.
		(+) And changes made in the function are visible to the caller.

	(Passing by Value vs Passing by Reference)

	In C++:
		int g (ReallyBig &rb) { ... }
		g(x);
			(+) This suppresses the copy.
			(+) Changes to rb are visible to the caller.
			(+) Automatic dereferencing.

	What if we want to suppress the copy but we don't want changes made to ReallyBig.
	Send it as a constant reference.
		int h (const ReallyBig &rb) { ... }
		ReallyBig x;
		h(x); // x is passed by reference (no copy is made, so this is efficient), but also can't be modified by h.
		// It's like you only have a read permission, but not a write permission.

	Note: This can be applied to struct Node, struct llist, etc. (The various data structures from CS136)
	Advice: Use pass by const reference for anything bigger than an int.
		int f (int &n) { ... }
		int g (const int &n) { ... }
		f(5); // trying to pass 5 by a reference, but this is illegal because 5 doesn't have an address (5 is not an Lvalue).
			f(y + y); // also doesn't work
		g(5); // compiler WILL allow this, because it is a const and can be stored conveniently. Compiler will remember 5 as long as you don't want to change it.
			g( y + y); // also works, for the same reason (as opposed to doing "int z = y + y; f(z);" every time).


Note: References can't be NULL (we will get back to this in 2 weeks).
"References are not the easiest thing to understand, go over this material and get good at using references." - NN


Dynamic Memory
	In C,
		int size = ...; // size of an array
		int *p = malloc(size * sizeof(int))
		free(p);
	
	Things are not a whole lot better in C++, but we don't have to do the "size * sizeof(int)" calculation.
	C++ Does support malloc() and free(), but DON'T use it (disallowed in this course)!
		instead, use 'new' and 'delete'

		In the linked list example (in C):
			struct Node {
				int data;
				Node *next;
			}

		Let's dynamically create a node, in C++:
			Node *np = new Node;

		'new' is type-aware.
			We don't need to compute the amount of memory we want.
			This is less error-prone. With 'new', you will always get enough memory (or you can receive an error, which we will come back to later).

		When you are done with the node:
			delete np;

		"Do not mix malloc/free with new/delete, that is the worst thing that you can do! Bad things happen. Don't do it. This is what happens when you combine C/C++ codebases." - NN
			delete looks at a book-keeping table that is only updated by new, so it can't recognize malloc'ed things.

	Dynamic Arrays
		Suppose I read in a number and create an array of that size:
			cin >> n;
			int *arr = new int[n]; // dynamically allocated array of size n! new is smart enough to do this!
			// You just tell n that you want n integers, and it uses its type-aware magic to calculate and allocate enough memory.

		Once you are done:
			delete [] arr; // a lot of people forget the '[]', then bad things happen.

			"Some course notes say that 'delete arr' would just delete the first element of the array. This is nonsense, it's really an undefined thing that is compiler-specific. Just remember the '[]'" -NN

		If you allocated memory, it is still your job to deallocate it.

		"And did I mention, don't forget the '[]'!" - NN

		Q: Can you delete something by reference?
		A: "Not sure, don't hold me to this, but I think that would work." - NN

Stack vs Heap Allocation (This should be review)
	You have access to some memory, which is divided into three things:
		program
		stack
		heap

		-----------
		| Program |
		-----------
		| Heap \/ |
		|      \/ |
		|      \/ |
		|      \/ |
		|         |
		|grows dwn|
		-----------
		| Stack ^ |
		|grows up |
		-----------

	Local Variables:
		Allocated on the stack.
		Stack space is reclaimed when local var goes out of scope (a function returns, etc. and the function's local vars are freed).

		Node n; // n is local variable on the stack
		Node *np = new Node; // new Node is on the heap (dynamically allocated) but *np is local, on the stack.

		    ...
		|         |
		| Node    |
		|         |
		|         |   (heap)
		-----------
		| np      |   (stack)
		| n       |
		-----------

	Heap-allocated data continues to live even when the pointer goes out of scope.
		That is a memory leak!
		(stack allocated local var of a heap-allocated value goes out of scope when, say, the function that assigned the var returns)
------------------------------------
Lecture 10

Memory Operations / The Preprocessor

	A function that returns a node:

		Node getMeANode() {
			Node n;
			return n;
		}

		This is problematic since node n is allocated in getMeANode's stack frame and must be copied to the caller's frame.
		This is inefficient. (Although it is critical for us to perform that inefficient copy here, to avoid data loss)

	If you instead return a pointer to a stack-allocated variable, really bad things happen.
	e.g.

		Node *getMeANode() {
			Node n;
			return &n;
		}

		This causes a 'dangling pointer'. You should NEVER do this.
		Returning a reference is equally bad, since it's referencing a variable that becomes lost.

	Create the node on the heap:

		Node *getMeANode() {
			Node *np = new Node;
			return np;
		}

		np, the node pointer, gets copied to the callers frame (this is efficient, since pointers are only 4 bytes). This suppresses the copy of the data structure.

		*Caller must keep track of the returned pointer and eventually free the memory.

		main() {
			getMeANode(); // Bad! Doesn't store the returned pointer, so we can't free the memory.
		}


Operator Overloading

	e.g.
		negate(int);
		negate(bool);

		<< and >> operators are overloaded (streams and I/O stuff, etc.)

		+ is overloaded (arithmetic and string concatenation, etc.)

	General Idea:
		We can give meanings to C++ operators for the types we define.
		e.g.

			struct Vector{
				int x,y;
			}

			We could write an addition function:

				Vector add(vec v1, vec v2) { ... }
				Vector v1 = { ... };
				Vector v2 = { ... };
				Vector v3 = add(v1, v2);

				But this is ugly and awkward to implement.
					Note that the behaviour behind creating a new vector (v3) from the existing returned vector is complex, and we'll get to this in another lecture.

			Instead, let's overload the + operator:

				operator+(const Vector &v1, const Vector &v2) {
					Vector v;
					v.x = v1.x + v2.x;
					v.y = v1.y + v2.y;
					return v;
				}

				Since our new header definition is unique, it is a valid overload.
				This can now be used with "V1 + V2" (where V1 and V2 are references).
					Note that this specific example is overloading a pre-defined C++ operator; we can also do this with our own functions.

			What if we want to do "Vec v4 = 3 * v3" or "Vec v5 = v3 * 3" ? This requires TWO overloads, for each new LHS/RHS behaviour of '*'.

				Vector operator*(const int k, const Vector &r) {
					// by convention we pass ints by value, since a reference is just 4 bytes anyways.
					// Remember to use const arguments whenever possible, this can earn marks in the hand-marking of our code.
					
					Vector toRet;
					toRet.x = k*v.x;
					toRet.y = k*v.y;
					return toRet;
				}

				Vector operator*(const Vec &r, const int k) {
					return k*v; // takes advantage of our other definition. Yay!
				}

				Update svn and look at lectures/c++/x-operators/

			Let's also show an overloading of << and >>

				Struct Grade {
					int theGrade;
				}

				This seems silly, since we could just use an int.
				BUT this lets us tell the compiler we're dealing with our own type, and lets us define overloads specific to grades.
					Note that we don't talk about typedefs in this course. "We don't talk about that, it would pollute your minds." -NN

				operator<<(ostream &out, const Grade &g) {
					// we don't want a const ostream, because we will set error flags if something goes wrong, etc. You can never really const an istream.

					out << g.theGrade << "%";
					return out; // follows the chaining convention of <<
					// DON'T return cout here, bad things would happen.
				}

				Note that we could use g now to output a stream to any other streams we can think of.
					e.g.
						cout << g;
						ofstream << g;

				We could define special Grade behaviour in the future. Like how the university caps your grade at 100% (and stops it from dropping below 0 :P)

				istream &operator>>(istream &in, Grade &g) {
					in >> g.theGrade;
					if (g.theGrade < 0) g.theGrade = 0;
					if (g.theGrade > 100) g.theGrade = 100;
					return in;
				}

				We are assuming that the LHS of the operator is already a Grade number.
				
				cin >> g1 >> g2;
				cin >> g1 >> g2;

Warning: one of the questions (the last one?) in Assignment 3 is very labour-intensive for writing test cases.
	You may want to write a script to do this, or sit two people down and play through to create test cases.

Preprocessor
	
	Source Code --> Preprocessor --> New Source Code --> C++ Compiler

	The preprocessor is the first thing that sees your source code.

	You are already using it.
		#include is a preprocessor directive.
			It says 'find the file specified and paste it right here in the code'.

		e.g.
			#include <iostream>
				This pastes iostream into your code.
				It looks in the standard C++ library (/usr/include/c++/lib ?)

		Alternatively,
			#include "vecotr.cc"
				This looks for files in this directory and pastes it in.

		"This is pretty straightforward stuff, the preprocessor isn't very smart." -NN

	The define directive:
		#define VAR value
			This creates a preprocessor variable and initializes it to a value.
			e.g.
				#define MAX 10
				int array[MAX];

		define is essentially a 'search and replace' function.
		Remember that this happens before the compiler even sees anything.
		The compiler will see "int array[10];"

		This behaviour predates const.
		Now, languages have cosnts.
		It is often encouraged to use built-in language consts instead of #define, but #define is not completely useless.
		This simple search-and-replace strategy is actually quite powerful.

		You can do some really cool/weird stuff with the preprocessor.
		e.g.
			#define ever ;;
			for (ever) {
				// infinite loop :D
			}

		This is fun for making convoluted code. There are ways to output what the preprocessor outputs and play with this.
		We could technically change how C++ code looks completely, if we do "#define while for" etc.
		"PLEASE DON'T EVER DO THIS, THE TAs WILL HATE YOU." -NN
		lol -JR

		Real-world use:
			Defined constants can be used for conditional compilation.
			If we want to write code that works on Unix and Windows, we have problems.
				Unix C++ applications need "int main(){ ... }"
				Windows native applications need "int WinMain(){ ... }"

				We could write two separate codebases...
				OR we could write one codebase that is compiled in two different ways!
				Defined constants are one tool that lets us do this.

				e.g.
					#define UNIX 1
					#define WINDOWS 2
					
					#define OS UNIX

					#if OS == UNIX
					 int main(){
					#elif OS == WINDOWS
					 int WinMain(){
					#endif

				We are only touching on this very briefly. You will probably see in the industry (on co-op) how it's done.

				Q: I compiled a C++ program with main on Windows. How?
				A: It was probably not a _native_ Windows application.

			We don't want to have to change "#define OS ..." every time!
				We can instead use Compiler Arguments.
				"Compiler arguments to the rescue!" -NN

				define.cc:
					main() {
						cout << X << endl;
					}

					This wont compile, X is not defined.

					g++ -DX=15 define.cc
					./a.out
					15

					It works with compiler arguments!
					-D is for preprocessor variables
					We can do
						g++ -DOS=UNIX ...
							This sets OS to UNIX

			Note how many different architectures there are nowadays: Win32, Solaris, iOS, etc.

			That will involve a lot of #if #elif usage.

	#define VAR
		This creates VAR, with a value set to the empty string.
	#ifdef VAR
		This condition is true if VAR is defined.
	#ifndef VAR
		This condition is true if VAR isn't defined.

		These can be used for debugging!
		Add a bunch of cout statements that can be removed automatically before submitting to Marmoset!

		Look at lectures/c++/6-preprocess/debug.cc for an example of this.
			DEBUG is not defined in this code, and then there are #ifdef statements.
			g++ -DDEBUG=1 debug.cc
			This will be REALLY useful for the big question on A3 or on our project.
----------------------------------------------------
Lecture 11

Note: Office hours moved to Wednesday 12-1:30 today.

Recall: Preprocessor
	Preprocessor Directives:
		#include
		#define VAR VALUE
			This is useful for conditional compilation.
		#define VAR
			The default VALUE is the empty string.
		#ifndef VAR
	Compile Time Preprocessor Args:
		g++ -DDEBUG
	Examples:
		preprocessor/define.cc
		preprocessor/debug.cc
	#if 0
		...
		Code not forwarded to the compiler.
		Fancy way to comment things out!
		...
	#endif

Separate Compilation
	Break our implementation into:
		1. Interface files (.h files)
			Contains type definitions (struct Node, etc.), function headers.
		2. Implementation file (.cc file)
			Contains implementation of functions.

	separate/example1:
	vector.h:
		struct Vec {
			int x;
			int y;
		}

		Vec operator+( ... );

	main.cc:
		#include "vector.h"
			// All the compiler needs to know is that an implementation for vector exists.

	vector.cc:
		#include "vector.h"
		Vec operator+( ... ) { ... }
			// Sees the type def for Vec in vector.h

	This separation is important in case someone wants to change the definition of "struct Vec". Having it defined in only one place is important.

	To compile:
		g++ main.cc vector.cc
		g++ *.cc
			This only works if your directory is well-organized.

	Note that .h files aren't to be compiled. Never compile header files, they are meant to be included (and then compiled) in .cc files.
		Compiling a .h will result in a .h.gch, a compiler header that takes priority over your other .h files. This will cause problems.
	Note: Never include .cc files.

	If you are building a huge video game and change one character, you don't want to have to change that character's definition all over the project.
	Separate compilation is about being able to compile individual pieces of a program and then combine them.
		This also helps for debugging. You can compile individual .cc files for debugging output instead of comiling the whole project.
		Error "ld": Linker error. Valid C++, but no defined main function is seen by g++.
			We can't compile separate pieces by default. g++ tries to compile AND link and produce an executable by default.
			g++ -c vector.cc
				This works, and outputs vector.o by default.
			g++ main.cc
			g++ vector.o main.o
			./a.out

		.o file is an object file.
			Contains:
				Binary for compiled code.
				Information about what is needed to link (what is available and what is missing).

		vector.o:
			Says we need operator+ implementation, and we need main.

		main.o:
			Says we have main, and we need operator+ implementation for Vec.

		Invoke the linker by giving all of the object files:
			g++ vector.o main.o
				Here, the linker is like a match-maker. It makes sure the needs of each object is met.

			This is separate compilation. If main.cc is changed, simply recompile main.cc and compile using the new main.o.

	Dealing with Global Variables when Using Separate Compilation:
		File abc.h:
			int globalVar; // declaration AND definition.
				Any .cc file that includes abc.h has a globalVar variable.
				When you compile this .cc file, the .o file will say "I have a variable called globalVar".
					The linker will recognize all of the .cc files including abc.h saying that they have globalVar variable.
					Linker will complain: You cannot have a var with the same name.

		Solution:
			1. Move definition to abc.cc:
				int globalVar;
				// Since we never include .cc files, abc.o will be the only one with a definition of globalVar
			2. We need a way to declare but not define this elsewhere. In abc.h:
				extern int globalVar; // "Somebody will define globalVar somewhere."
				// "Forward declaration of vector.h"

		See separate/example2/

	separate/example3/
		g++ *.cc
		Compiler error: redefinition of 'struct Vec'.
			Both linearAlg.h and linearAlg.h contain "#include vector.h".
			linAlg.cc includes both of these .h files, so it sees two definitions of vec.

		To fix this:
			1. Don't include vector.h twice. This is hard to keep track of though.
			This is the very reason why we talked about the preprocessor!

			2. Use include guards.
				vector.h:
					#ifndef __VECTOR_H__
					#define __VECTOR_H__

					struct Vec { ... };
					Vec operator+( ... ){ ... };
					#endif

					This prevents the inclusion of the same piece of code multiple times.
				
				Advice: Always have include guards in .h files.
					In CS246: This will give us handmarking marks!
					In real world: This is good practice!
				More advice: Never use "using namespace std;" in header files. All .cc files that include that .h would be forced to use that namespace!
					Always refer to cout as std::cout, cin as std::cin, string as std::string, etc.
					Maybe somebody wants to implement a String type in their .cc file.
					We CAN use the namespace in our implementation.

Classes
	The big idea behind Object-Oriented Programming (OOP) is that you can put functions inside of structs.
	e.g.
		Struct Student {
			int assns, mt, final;
			float grade () {
				return 0.4*assn + 0.2*mt + 0.4*final;
			}
		};

		This is a struct with a function in it. A class!

		Create the student:
			Student s = {80, 55, 70};
		Call the grade function:
			s.grade();

			We are calling a function that is defined inside a struct.

	A class is a struct that can contain functions.
		All C++ structs can contain functions, so they are all classes!
		"class" keyword exists: We will talk about this later.
		For now, when we say "class", we are talking about a struct with functions.

	An instance of a class is called an object.
		Above, 's' is the object and 'Student' is the class.

	A function residing insed a class is called a member function or a method.

	In grade() above, we use FIELDS of the struct instead of local variables.
		This method is using variable names it has not declared.
		This structure definition does not reserve any memory, it just says what it means to be a student.
		What do assns, mt, final refer to in grade()?
			They refer to the assns, mt, and final for the object on which grade was called.
			They are the fields of the current object.
				Student s = {80,55,70};
				s.grade(); // assn, mt, final marks of s

				Student billy = {80, 70, 90};
				billy.grade(); // billy's grades are used
--------------------------------------------------
Lecture 12

Recall from last time:
	Struct Student {
		int assns, mt, final;
		float grade() {
			return assns*0.4 + mt*0.2 + final*0.4;
		}
	}

	Student s = {80,55,70}; // c-style initialization
	s.grade();


Function vs Method
	Method has an additional hidden parameter called "this".
	"this" is a pointer to the object on which the method was called.

	Inside grade,
		this == &s
		*this == s

	In the grade() code above,
		this->assns*0.4 +
		this->mt*0.2 +
		this->final*0.4;

		This is equivalent to the previous example, since we don't explicitly need to use "this".
		Sometimes it is useful to disambiguate between global variables and fields, etc.

Constructors
	Now:
		Student billy = {90, 80, 70};
			90, 80, 70 are compile-time constants. This is limited and unrestricted (we could give a mark >100).

	It would be nice to be able to do arbitrary computation for initializing an object.
	We can implement constructors, which are methods used to initialize objects.

	Struct Student {
		int assns, mt, final;
		float grade() { ... };

		Student(int assns, int mt, int final) { // A constructor! These must be the same name as the class, and can't specify any other return type.
			this->assns = assns;
			this->mt = mt;
			this->final = final;
		}
	};

	"this" came in handy here to differentiate between constructor arguments and the object's fields.
	Note that we can perform computations/checks before assigning the field values.

	We can call the constructor with the following (both of these are EXACTLY the same):
		Student billy(80, 55, 70);
		Student billy = Student(80, 55, 70);
			
		Both of these allocate objects on the stack.
		If we want billy to reside on the heap:
			Student billy = new Student(80, 55, 70);
				The above line is incorrect. "new" always returns a pointer, not an object.
			Fixed:
				Student *billyPointer = new Student(80, 55, 70);
				...
				delete billyPointer; // "Billy is now gone. I feel like God." -NN

	We have used constructors already in our code: "iStringStream ss(s)".

	Advantages of Constructors:
		(+) arbitrary computation (they are functions, so we can do anything)
		(+) default arguments
		(+) overloading

	e.g.
		Struct Student {
			int assns, mt, final;
			...
			Student(int assns=0, int mt=0, int final=0) {
				this->assns = assns;
				this->mt = mt;
				this->final = final;
			}
		};           // Don't forget the semicolon!

		The above can take 3, 2, 1, or 0 arguments.
			Student s(60, 70, 80);
			Student s1(60,70); // final = 0
			Student s2(60); // mt = final = 0

		You would think you would utilize all three default arguments with the following:
			Student s3(); // incorrect
		But wait! That looks exactly like a declaration, and C++ would treat it as such.
		Instead, we do:
			Student s3; // assns = mt = final = 0

	Every class comes with a default (0-argument) constructor that calls default (0-argument) constructors on fields who have constructors.
		e.g. String class has a default (0-argument) constructor.
		e.g. Struct Vec { int x, y; }; // also comes with a default constructor
			 Vec v; // calls the default constructor! x and y are uninitialized though.

		Base types and primitive types (e.g. int) are left uninitialized, but other objects are initialized (say, if we had a Student inside Vec).

		The default constructor goes away as soon as you write a constructor of your own.
		e.g.
			Struct Vec {
				int x, y;
				Vec(int x, int y) {
					this->x = x;
					this->y = y;
				}
			};

			Now, calling "Vec v;" would not compile because our default (0-argument) constructor has gone away.
			Calling "Vec v(1, 2);" is how we need to call this constructor.

		As soon as you write a constructor, you also lose c-style initialization ("Student s = {60, 70, 80};").
		As soon as we write a constructor, C++ knows we are  treating these as objects, so it gets rid of the structure behaviour inherited from C.

	Odd technical example:
		struct MyStruct {
			const int myConst;
			int &myref;
		}

		The above should look strange, because the above variables would normally have to be initialized.
		However, the above is correct.
		Field initializers are not allowed here in the definition.

		struct MyStruct {
			const int myConst = 5; // not allowed
			int &myref = m; // not allowed
		}

		We can't do this. What if we want each object to have a constant field that we define during initialization? The above would contradict our ability to do that.
		You cannot initialize constants/references in the constructor body, either! At that point, it's too late (see below).

		Potential midterm question: What happens when an object is created?
			1. Space is allocated (on the stack or on the heap, depending on how it's created).
			2. Fields are initialized and default constructors (if present) are created.
			3. The constructor body runs.

		To fix this initialization problem, we will hijack step 2:
			Member Initialization List
				Note: We can only do this for a constructor, not on any other method in the class.

				Struct MyStruct {
					const int myConst;
					int &myRef;
					MyStruct(int c, int &r):       // Woah!
						myConst(c), mrRef(r) {     // Done with member initialization list, continue with constructor body.
							...
						}
				};

				Fields are initialized in declaration order, irrespective of the order in the member initialization list.
				Step 2 above no longer executes. We have circumvented it.
				We can use MIL whenever we write a constructor.
				e.g.
					struct Student {
						int assns, mt, final;
						Student(int assns, int mt, int final)
							: assns(assns), mid(mid), final(final) {} // Valid!
					};

					"assns(assns)" is the same as writing "this->assns = assns". Inside the MIL, we guaruntee that the names used are fields. The regular scope of variables also applies.

				Advantages of the MIL:
					(+) only way to initialize constants/references
					(+) can use the same name for fields/parameters (no need to type "this->")
					(+) can be more efficient (we don't initialize the default values then overwrite them in the constructor body, only 1 assigment per field)

				Let's say we have a Vec inside the MIL:
					struct Student {
						int assns, mt, final;
						Vec V;
						Student(int assns, int mt, int final)
							: assns(assns), mid(mid), final(final) {} // Valid!
					};

					Above, the default Vec constructor will be called if we don't put it in the MIL.
						"We can call non-default constructors ourselves, but we will discuss that later in the term." -NN

	Copy Constructors and Shallow Copy vs Deep Copy
		Consider the following:
			Student billy(60, 70, 80);
			Student bobby = billy;
		How does this initialization occur?
		We are constructing an object as a copy of another.
		We are calling the Copy Constructor.
			It takes one parameter which is a constant reference to the type of the class.
			You get a default copy constructor for free. It does a field-for-field copy.
			Note: We get two other things for free - Destructor and Copy Assignment Operator (we will discuss these on Thursday).

			The default copy constructor looks like this:
				struct Student {
					Student(const Student &other)
						: assns(other.assns),
						  mt(other.mt),
						  final(other.final) {}
				};

			Rule of thumb: Any time dynamic memory comes into play, we must write our own constructor/destructor/copy-constructor.
			e.g.
				Struct Node {
					int data;
					Node *next;
					Node(int data, Node *next): data(data), next(next) {} // constructor
					Node(const Node &other): data(other.data), next(other.next) {} // what our default copy constructor looks like (only a "shallow copy")
				};

				Node *n = new Node(1, new Node(2, new Node(3, NULL)));
				Node m = *n;
				Node *np = new Node(*n);
				Let's look at the memory here, in a linked-list style pointer diagram (n, m, np are on the stack, things created with new are on the heap):

					n[  ]->[ 1 ][  ]->[ 2 ][  ]->[ 3 ][ \ ]
					         ^          ^
					        /		    |	
					m[ 1 ][  ]          |
	                                    |
					np[  ]-->[ 1 ][  ] -'

					Not three copies of the entire list! It's just a shallow copy!
					Only one new Node pointer is created. If the original list (n) gets deleted, m and np will not point to valid blocks of memory!

			We need to perform a "deep copy" to create an entirely new linked list.
			Deep copy constructor:
				Node(const Node &other):
					data(other.data),
					next( other.next ? new Node(*other.next) : NULL)
					{}

				If other.next isn't NULL, point to the next Node.
				Node(*other.next) is a recursive call to the copy constructor.

		Lots of excellent examples in classes/constructor/
		"VERY GOOD TO STUDY FOR THE MIDTERM!" -NN-------------------------------------------------
Lecture 13

"Content up to and including this lecture will be covered on the midterm, but not the next lecture. Study all of this!" -NN

More notes on copy contructors:
    Places where a copy constructor is called:
        When an object is constructed as a copy of another.
        When we pass an object by value (and a copy of it is created for the function being called).
        When we return an object from a function.

    A copy constructor takes its only parameter by const reference. The other object isn't changed.
        Note that it has to be a reference, because to pass in an object by value you must run a copy constructor! This would create an infinite loop here.

Recall the four things that we get for free:
    Default constructor
    Default copy constructor (only does shallow copies)
    Destructor
    Assignment creator

Destructors
    When an object is destroyed, a method called the destructor runs.
        A stack allocated object is destroyed when it goes out of scope.
        A heap allocated object is destroyed when you call delete on its pointer.

    A destructor:
        Takes no arguments.
        Has the same name as the class, prefixed with a tilde (~).
    A class only has one destructor.
    There is a default destructor. It automatically calls destructors on any fields which are objects.
        Note that base types and pointers to objects don't have destructors.
            It's important that pointers don't have destructors by default. If they are pointing to something important, we may need a custom destructor.
                e.g.
                    Node *np = new Node(1, new Node(2, new Node(3, NULL)));

                    stack    --------- heap ---------

                     np --->[1][ ]--->[2][ ]--->[3][/]

                    If there is no call to delete:
                        np, being stack allocated, is reclaimed. No destructor runs!
                        Three nodes are leaked!
                    If we call delete on np:
                        Called destructor on [1][ ]--->
                            The default destructor runs.
                        No destructors for fields!
                        Two nodes are leaked!

                    We need a custom destructor.

    Custom destructor example:
        struct Node {
            ...

            ~Node(){
                delete next;
            }
        };

        Now, calling delete on np:
            This calls delete on the next Node(s) recursively and stops appropriately when the end (NULL pointer) is encountered.
            Note that calling "delete NULL;" won't create any error, delete is smart enough to not do anything.
            The first part is deleted because this whole recursive delete process is started with "delete np;".

"Another thing I'm squeezing in today... you can guess why." -NN ;)

Recall separate compilation:
    Interface (.h) files: type definitions and function headers.
    Implementation (.cc) files: implementation of functions.

    This approach is now problematic because we are implementing method definitions inside class declarations, so we would have implementations in header files!
    Now we will stop implementing methods inside class definitions.
    Instead:
        For a class, give method headers in the .h file.
            e.g. (.h file):
               struct Node {
                    ...
                    ~Node();
                    Node(int data, Node *next);
                };

        We will put the implentation of ~Node in a .cc file.
            How does the compiler know that ~Node belongs to the Node class?
                We use the scope resolution operator.
                In the .cc file:

                    Node::~Node() {
                        std::cout << "Destructor called" << std::endl;
                        delete next;
                    }

                    This defines ~Node in the scope of Node.
                    "We still always need include guards in our .h files. We will lose "
                    See /lectures/c++/8-classes/separate/

                Use Node:: in .cc files.
                    This is called the scope resolution operator.
                    Node::getData()
                        getData in the context (scope) of the node class.

"Now, perhaps the most technical of the four methods you get by default." -NN
"We will show two ways this is done. Study both ways as much as you can." -NN (hint hint)

Assignment Operator
    Student bobby(60, 70, 80);
    Student billy = bobby; // copy constructor
    Student jane; // zero-argument constructor
    jane = bobby; // jane already exists! We are re-assigning its fields to be a copy of bobby.
         ^assignment operator (=)

    We get a default assignment operator:
        Default "operator=" (assignment operator) does a field-for-field copy.
        For Student, the default operator= works fine!

    We must implement our own assignment operator if dynamic memory is involved.
        struct Node {
            ...
            Node &operator=(const Node &other) { // other is the right hand side of the assignment
                // The return type is a Node reference so that cascading works (we have seen this reasoning before).
                // Remember that this is NOT a constructor.

                // Default implementation (only a shallow copy):
                //     data = other.data;
                //     next = other.next;
                //     return *this; // *this is the object

                // To get a deep copy, we must create new Nodes.
                data = other.data;
                // next = new Node(*other.next); // Call to copy constructor (must already be implemented). This can cause errors if we encounter a NULL pointer.

                next = other.next ? new Node(*other.next) : 0; // 0 is equivalent to typing NULL
            }
        }
        "If your copy constructor and assignment operator look very similar, you have done something wrong." -NN
        Don't overwrite the next pointer straight away, that creates a memory leak!

            Node &operator=(const Node &other){
                data = other.data;
                delete next;
                next = other.next ? new Node(*other.next) : NULL;
                return *this;
            }

            This is still wrong! It breaks with self-assignment:

                Node n(1, new Node(2, new Node(3, NULL)));
                n = n;

                Node &operator=(const Node &other){
                    n.data = n.data;
                    delete n.next;
                    n.next = n.next ? new Node(*n.next) : NULL; // now this behaviour is undefined, since n.next has been deleted!
                    return *this;
                }

           We must ALWAYS check for self assignment (check if other is equal to this).
           Note that we only have this problem in the assignment operator, because we could only be referencing the same object here.

            Node &operator=(const Node &other){
                if (this == &other) return *this;
                data = other.data;
                delete next;
                next = other.next ? new Node(*other.next) : NULL;
                return *this;
            }

            For CS246, we are done. Lots of technical details here, be sure to study it.

            In the industry (we don't need to know this) your code has to be more robust.
                What happens if we run out of memory when we try creating new Node?
                If the call to new fails, code execution stops for this method, the stack is unwound.
                next is now a dangling pointer. It has not been set to NULL, nor does it point to anything.
                To fix this problem, delay the delete until after the next Node is created.
                    This is called a delayed delete:
                        Node &operator=(const Node &other){
                            if (this == &other) return *this;
                            data = other.data;
                            Node *tmp = next;
                            next = other.next ? new Node(*other.next) : NULL;
                            delete *tmp
                            return *this;
                        }

                "We don't need to do delayed delete on the exam, but we must check for NULL, return *this, etc." -NN

        Another, easier to understand implementation of an assignment operator:
            Copy and Swap Idiom

                struct Node{
                    ...
                    void swap(Node &other){ // NOT a const reference
                        // Swap all the fields of a given object.

                        int tdata = data;
                        data = other.data;
                        other.data = tdata;

                        Node *tnext = next;
                        next = other.next;
                        other.next = tnext;
                    }
                    Node &operator=(const Node &other){
                        Node tmp = other; // calls copy constructor
                        swap(tmp);
                        return *this;
                    }
                }

                Notice that we never used delete. We assigned tmp to be a copy of other ON THE STACK.
                Note that this requires a functioning copy constructor.
                "Node tmp = other;" would call a deep copy constructor, so no recursion is neeed in the assignment operator.
                Before returning *this, "this" has the needed fields, and tmp has the old fields.
                This also relies on having a functioning destructor, because it will be called on tmp when it goes out of scope.

Summary of today's lecture and yesterday's lecture:
    Rule of 3
        If you need to implement a custom version of the copy constructor or the destructor or the assignment operator,
        then you usually need to implement all three.

Office hours 2-4:30pm today. 10 minute limit per student if it's busy.
