CS246 Object Oriented Software Development
Nomair ("Numer[ical]") Naeem
	Also taught: CS241 'baby compilers course', CS444 'advanced compilers course'
	nanaeem@uwaterloo.ca 'prefer not to get emails for general course-related questions'

Course Breakdown:
	Final Exam - 40% - 2.5 hours
	Midterm - 20% - October 23rd - 4:30-6:20 (typical average 55-65% 'nice wake up call')
	Assignment - 40% - Six of them - A0 already out, worth no marks, prereq for future marks
		A1-A4 - worth 7% each, done individually
		A5 - worth 12%, small-medium sized project in groups of two, partner doesn't have to be in same section (same time frame as typical assignment, ~2 weeks)

		Two due dates - end of first week, end of second week
		Using Marmoset
		ISA: Kristen Bradley
		Tutorials: 'not compulsory, but encouraged', none in first week
		Lab hours in week 1: help for a0, MC 2062/2063, email cs246@uwaterloo.ca for help, 10-12, 2-3
		Piazza: monitor daily, check for already answered questions
		Reference materials: textbook not required, no course notes
		Academic integrity: 'do not cheat', 0% on assignment and -5% on course mark
		Welcome to second year: assignments get more difficult, longer description, less spoon-feeding, READ QUESTIONS MULTIPLE TIMES, no solutions provided

	You must use a *nix environment or SSH+WinSCP or Cygwin
	Use the cs136 virtual box (works fine until a3), not recommended
	MANAGE YOUR TIME

4 MODULES
	1 - Introduction to Unix Shell (2-3 weeks)
	2 - C++ 03 'Object Oriented Software Development' (10 weeks)
	3 - Tools
	4 - Software Engineering Principals

Module 1: Linux Shell
	interactive environment  - an interface to the Operating System
	Shell: how we get the OS to do "things" for us.
	Two kinds of shells:
		- Graphical
		- Text-based (command line)

	1. Graphical (eg. Windows, OSX, Gnome, KDE)
		+ Intuitive to use
		+ Mouse clicks
		+ Drag and drop
		- harder (difficult) to do less common tasks (eg. batch-renaming of files ending in cpp to cc)

	2. Command Line Shell
		Interface to unix/linux environment
		Even Windows has a command-line shell (DOS)
		+ Much more powerful
		- Must learn basic commands (steep learning curve)

	History of UNIX Shell:
		Linux has its roots in the original unix OS (70s)
			- The original unix had a command line shell ("Shell", "BourneShell" to differentiate)
			- Written by Stephen Bourne
		Other Shells:
			- CShell (csh)
			- KornShell (ksh)
		These shells also evolved
			- csh became tcsh
			- BourneShell became BourneAgainShell (BASH)
		Command: echo $0
			> 'bash' ($>) or 'tcsh' (%>)

	Linux File System
		- Contains files
			- files (data/programs) 'ordinary files'
			- directory (can contain other files) 'just like folders in Windows'
			/
				bin/
					bash/
					ls/
					cd/
				etc/		(configuration files)
					shells
				home/
					nanaeem/
						cs241/
						cs246/
				usr/		
					bin/	(user programs)
					include/	(C headers are located)
		- Root of the tree structure is a dir called '/'
		- Can have two files with identical names as long as they are in different directories
		- We can specify any file by giving its path
		- '/bin' means 'bin' directory inside '/' directory
		- '/user/bin' - bin directory inside the 'usr' directory inside the '/' directory
		- Current Directory:
			- The directory we are currently in
			- Command 'pwd' (present working directory) outputs current directoryDirectories start from root '/', these are absolute paths
Relative paths start from the current directory
	If current dir is '/home/nanaeem/cs246', then the file (remember, directories
	are actually files) 'Fall/a0' is the same as '/home/nanaeem/cs246/Fall/a0'.
	The advantage of relative paths is that it reduces typing.

Four different special directories:
	1. '.' - refers to current directory
		eg. '$> cd .'  does nothing
	2. '..' - refers to the parent directory
		eg. '$> cd ..' changes pwd to parent directory
		If you want to get to the grandparent, '$> cd ../..'
	3. '~' (Tilde) refers to the home directory
		'$> cd ~' changes to home directory
		Shortcut: '$> cd'
		Can continue path '~/cs246/Spring'
	4. '~userid' - userid's home directory (useful for sharing files between unix accounts)
		eg. '$> cd ~nanaeem'

To see the contents of a directory use 'ls' command (listing)
	- Shows files in your current directory
	- Does not show hidden files (starting with '.', icluding special dirs './' and '../') by default
	- 'ls -a' shows all files

In unix, there is no concept of file extensions (like .txt), although conventions are often enforced.

Wildcard Matching
		List all files ending with '.txt':
				'$> ls *.txt'
					   ^^^^^ globbing pattern
					   ^     match anything
					    ^^^^ that ends with '.txt'
				'globbing' comes from a legacy Glob program that performed wildcard searches
				The shell finds all the files that match the globbing pattern, and replaces the globbing pattern with those files.
				'ls *.txt' --> 'ls sample.txt t1.txt t2.txt'
				The shell is doing the hard work here.

				Behaves the same here as 'echo *.txt'
'$> rm' removes (permanently) the specified file(s)
	- University pays $45k a year with snapshot
	- 'Google version control'

'$> echo' parrots whatever the input is.
	'$> echo '*.txt'' outputs *.txt
	Single quotes and double quotes nehave the same here.
	Do a man ls

CTRL-C to kill execution of curent program.
CTRL-D sends EOF. (Useful for telling cat to stop listening to stdin and clean up execution)
Working with files
	'$> cat' (concatenate)
		Show or display contents of a file.
		Simply typing 'cat' will hang the program until text is input.
		'cat > output.txt' output redirection
		if output.txt exists already, it will be overwritten
		After pressing Enter, the line is written to the file

	In general: 'command args > filename' puts any output into file
	This is called output redirection.

	Input redirection: 'cat < sample.txt', which is equivalent to 'cat sample.txt' here. But with redirection, the shell is opening the file instead of cat.
		If file contains another filename, it only prints the filename.

	'$> wc filename' wordcount
	'wc sample.txt' outputs filename because wc opens the file, but with 'wc < sample.txt', wc doesn't know the filename
	'cat < output.txt > myfile.txt'
	Note that shell commands will create the file if it doesn't exist, or overwrite the file if it does!

Every process is attached to three streams:
						  /--- stderror (standard error)
	stdinput --- [program]
						  \--- stdout (standard output)

	stdin - Where the input comes from (default: the keyboard).
	stdout - Where the output goes (default: screen). This is buffered, and flushed periodically.
	stderr - Where the errors go (default: screen). Seen immediately, one character at a time (never buffered).

	Input redirection changes stdin from keyboard to files (or socket from the internet, etc.)
	$> myprogram < in.txt > out.txt 2> error.log
		'2>' handles stderr stream

What if you want to append to a file? Go to the tutorial.

Pipes ('|')

						  			  /--- stderror2
	stdout1 | stdinput2 --- [program2]
						  			  \--- stdout2

	Pipe output of process 1 into process 2.
	'$> process1 | process2'
	(| is also bitwise OR in C)

	Example 1: How many words occur in the first twenty lines of sample.txt?
	'$> head -20 sample.txt | wc -w' --> 165

	Example 2: Suppose files w1.txt and w2.txt contain lists of words, one per line. Print a duplicate-free list of all words.
	uniq - checks for duplicates that are adjacent, so we must sort first.
	sort - sorts
	'$> cat w1.txt w2.txt | sort | uniq'
Pipes
	last class:
		head -20 sample.txt | wc -w

	Equivalent to:

		head -20 sample.txt > temp.txt
		wc -w temp.txt

	The benefit of using pipes is to prevent using time/memory to write output to the disk.

How to pass the output of a program as an argument to another program.
	e.g. $ echo Today is date and I am whoami
	--> Today is date and I am whoami

	Put command in back-quotes (under tilde): Today is `date` and I am `whoami`
		7 words act like 7 arguments passed to echo.
	Also valid: echo "Today is `date`" (shell can execute commands in double quotes)
				echo Today is $(date)  (this syntax has the advantage of nesting without messy escaping)

Pattern Matching Inside Files
	Tool: grep (Global Regular Expression Pattern) (outdated)
		  egrep (Extended '''), equivalent to grep -E

		Usage: $ egrep pattern file
		Output: lines in file that match the pattern

		e.g. Find all occurences of cs246 in index.shtml
		  	$ egrep cs246 index.shtml
		  	--> All lines of html containing substring "cs246"
		
		Find occurences of 'CS246' or 'cs246'
		Student: {CS,cs}, egrep -e?
		OR '|': egrep cs246|CS246 index.shtml --> bash interprets this as a pipe!
			Use quotes: egrep 'cs246|CS246' index.shtml
			Or, alternatively:
			egrep "(CS|cs)246" index.shtml
			egrep "(c|C)(s|S)246"

Use Regular Expressions
	e.g. lines that contained cs246 OR CS246
		"cs246|CS246"
		===
		"(cs|CS)246"
		!==
		"(c|C)(s|S)246"

	a|b|c|d (a or b or c or d)
	Instead, use square brackets: [abcd]
		This chooses one character from this set.
	Ranges: [0-9]
		This chooses one digit from 0 to 9.

	All characters except certain cahracters: [^abcd]
		Any one character *except* a character from this set.

	e.g. What if we want an optional space between cs and 246?
		'?' is used to indicate 0 or 1 of the preceeding expression.
			$ egrep "cs( )?246" index.shtml
				Equivalent to: "cs ?246" without parenthesis, the preceeding expression/character is used (but brackets are encouraged)

	'*' is used to indicate 0 or more of the preceeding expression.
		e.g. egrep "(cs)*246" index.shtml
			--> 'cs246', '246', 'cscs246', 'cscscs246', ...
		If one line is matched it gets printed regardless of multiple matching cases.
		Cases regarding smallest/biggest matches, 'greedy' matching algorithms (largest match) are discussed in cs240.

	How do you find a '*' or a '?'?
		Escape it using '\'.
		e.g. "cs\?246"
			This escapes the special symbols (anything that has meaning within a regex)

		Remember - "Am I writing a globbing pattern or a regex?"
			Globbing pattern: '*' matches anything
			Regex: match 0 or more

	Dot ('.') matches any one symbol.
		e.g. egrep "cs.*246" index.shtml
			This matches ~~~cs~~~~~~246~~~, e.g. 'FOOcs246BAR'

	Carat ('^') (outside brackets) matches patterns at the beginning of the line.
		e.g. "^cs246"
			This gives all lines that start with cs246.

	Dollar ('$') matches ending characters.
		e.g. egrep "cs246$"
			This gives all lines that start with cs246.
		e.g. egrep "^cs246$"
			This gives all lines that contain exactly this string.

	Plus ('+') matches one or more of the preceeding expression.
		e.g. egrep ".+" index.shtml
			This prints all non-empty lines.

	*Note that there is a difference tbd between single and double quotes.

Useful egrep switches:
	Print all words of even length from /usr/share/dict/words
		Incorrect: $ egrep "(..)+" /usr/share/dict/words
			This returns all lines, since this isn't starting at the beginning of the line. All even substrings get found!
		Correct: $ egrep "^(..)+$" /usr/share/dict/words

	*Don't forget ^/$ on the assigment!

	Print all files in the current directory whose name contain exactly one 'a'.
		$ ls | egrep "^[^a]*a[^a]*$"

	Print all words in /usr/share/dict/words that starts with an e and has length 5.
		$ egrep "^e....$" /usr/share/dict/words

----------
$ egrep -i
	This ignores case

$ egrep ./*
	Globs all files in directory.

$ egrep -R
----------

File Permissions
	$ ls -l
		Long listing that gives additional information on each file.
			Contains permissions strings!
		-rw-r--r-- 1 nanaeem staff 10K [Date Modified] [Filename]
				   ^ indicates number of symbolic links to this file
				   	 if this is a directory, indicates number of files within + number of sym links to the dir
				   	 'all references to this file'
				     ^^^^^^^ owner
				     		 ^^^^^ group
				     		 	   ^^^ size
			'-' indicates ordinary file
			'd' indicates directory
			'l' indicates symbolic link (shortcuts)

	Group: way to share files in linux.
		A linux user can belong to many groups.
		A file can belong to one group.

		Permission: 3 groups of 3 bits
			User bits, group bits, other bits
			r -> read or set to '-'.
				File: read (cat, etc.). Directory: read contents of directory (ls, etc.).
			w -> write or set to '-'.
				File: write (vi, etc.). Directroy: modify contents (add/remove files, etc.).
			x -> execute or set to '-'.
				File: treat a file as a program and try to run it. Directory: you can enter that directory (cd, etc.).
			All On: rwxrwxrwx
			All Off: ---------
			Read, write, execute
		e.g. -rw-r--r-x
			Owners (user) can read and write, group can read, others can read and execute.
		chmodFile Permissions:
	The owner of a file is the only one who can change file permissions
		You can't grant the permission for other users (non-owners) to change permission
	$ chmod [mode] [file]
		changes permissions
		Mode:
			ownership class:
				u = user
				g = group
				o = others
				a = all
			operator:
				+ add permission
				- remove permission
				= set exactly
			permission:
				r read
				w write
				x execute
	e.g. Give others read permission
		chmod o+r file.txt 		*Implicityly removed pre-existing permission

	You can specify mode with 3-digit numbers (you don't have to know this)

	e.g. Revoke execute permission from group
		chmod g-x file.txt

	e.g. Make everyone's permission exactly rx
		chmod a=rx *.cc 	*If it was a+rx, a pre-existing w permission wouldn't be overwritten

	e.g. Change owener's permissions
		chmod u-rwx *.* 		*You always have permissions. You can always re-give yourself permissions.

Scripting
	e.g. $ x=1			*No spaces, or else it'll try to execute a program
		 $ echo $x

		 To set a variable do not use $
		 To access the value of a variable use $ and {}
		 	e.g. ${x}
		 The value of a variable is always a string
		 	e.g. x=1 		*1 is the string '1'

	Some variables are global:
		Path - variable
			Colon-separated list of linux paths.
			Used for ls as ls is not built in. Shell looks in all directories specified in path.
			*Do not overwrite path

	.bashrc (how to set variables that stay)

	A script is a file containing a sequence of linux commands which we can execute as a program.
	e.g. Print the date, current user, and current directory.
		./basic:

		#!/bin/bash   			"hash, bang; shebang line"
		date
		whoami
		pwd

	Command line arguments to a script:
		inside the script:
			$1 first arg
			$2 second arg
			.
			.
			.
			$n nth arg

		e.g. Check whether the input word is in the dictionary.
			#!/bin/bash
			egrep "^$1$" /usr/share/dict/wprds
			Right now, if $1 is a word, $1 will be printed. Else, nothing is printed.

		e.g. A good password is not a word in the dictionary. Answer whether the password is good.
			#!/bin/bash
			egrep "^$1$" /usr/share/dict/words > /dev/null  	"black hole used to discard input"
			if [ $? -eq 0 ]; then
				echo "Not good password."
			else echo "Maybe not a good password."
			fi  		"This closes the if statement."

			*-ne Not Equal
			*-lt Less Than

		'if' is running a program called '['
			Anything after '[' are arguments.
			'[' evaluates condition, sets status code
			'if' checks the status code

		Look at:
			goodpassword check  *${#} contains the number of arguments to the script
			goodpassword usage () { }    *A function.

	General format for an if statement:
		if [ condition ]; then
			# Block of code.
		elif [ condition ]; then
			# Block of code.
		else # Line of code.

		"Look at rename c and count words for loops"Loops
	e.g. Print all numbers from 1 to $1 ($1 is the first argument to our script)
	#!/bin/bash
	# count limit ---counts the numbers from 1 to limit
	usage () {
		echo: "Usage: $0 limit" 1>&2
		echo " where limit is at least 1" 1>&2
		exit 1
	}

	if [ $# -ne 1 ]; then
		usage
	fi

	if [ $1 -lt 1 ]; then
		usage
	fi

	x=1
	while [ $x -le $1 ]; done			# 'le' less than or equal
		echo $x
		x=$((x+1))			# "$x+1" would do string concatenation
	done

For Loop
e.g. Rename all .cpp files to .c 	# scripts/RenameC
#!/bin/bash
for name in *.cpp; do
	mv ${name} ${name%cpp}cc
done

Here, the shell replaces *.cpp with a space delimited list of filenames. (a1.cpp a2.cpp ...) (globbing pattern gets replaced just before the loop's execution starts)

e.g. How many times does word($1) occur in the file($2)
#!/bin/bash
x=0
for word in `cat "$2"`; do 			# 'for word in cat $2' (without backquotes) will get the word 'cat' then the filename 
									# GOTCHA: put double quotes around command arguments (without, strings with spaces are treated as multiple objsects, such as "hello word")
	if [ $word = $! ]; then 		# '=' is used for string equality (strings on both sides) or for arithmatic (integer values)
		x=$((x+1))
	fi
echo $x
done

Payday is the last Friday of the month.
What date is this month's payday?
$ cal | awk '{print $6}' | egrep [0-9] | tail -1
/cs246/1149/lectures/shell/scripts/paydayThisMonth
# elif [ $1 -eq 22 ]; then
#	echo "on the ${1}nd"


Testing
	In this course, you will be expected to fomrally test your code before submitting.
	- Use the script we ask you to write in a1 (runsuite)
	Each assignment has 2 deadlines
		Due date 1: test suites
			Run on a correct program (public)
			Release tests are buggy programs that we created. "The test suite that you created should be thorough enough to catch all of our bugs."
		Due date 2: code
	Testing tips:
		negative/positive values
		edge cases [0-10] check 0 and 10
		corner cases (multiple simultaneous boundaries)
	This is black box testing (we do not see the implementation)
	White box: full access to implementation
	Grey box testing: some limited acces to control flow of the program

	*Read through assignment very carefully
	*Think carefully about what the edge/corner cases are, etc. (max X, max Y)

Module 2: C++
Bjarne Stroustrup in the 80s
	Worked at AT+T labs (same place where UNIX and C were invented)
	Colleagues were inventors of C, UNIX
	Playing with the language called Simula67 (considered the first OOP language)
	Came up with 'C with Classes'
C++ is too big to cover in one course.
We will introduce the core concepts.
We will focus on C++03, which is reasonably sized
	New version is C++11, which has sme very sophisticated new concepts.
	UW's CSCF/MFCF still don't support C++11

hello.cc:
--------------------------------------
#include <iostream>
using namespace std;

int main() {
	cout << "Hello World" << endl;
	return 0;  						  // return statement must be explicitly defined in c++
}
--------------------------------------

Output in C:
#include stdio
printf('Hello World')

stdio/printf is available in c++, but DON'T USE IT!

Preferred c++ I/O
	#include <iostream> 	(no .h)
	std::cout << data1 << data2;
	std::endl;  		// newline (\n)

Using G++ compiler
Compile:
	$ g++ hello.cc
	Creates an executable called a.out (default name)
	$ g++ hello.cc -o myprog
	Creates an executable called myprog

	Execute with $ ./a.out, $ ./myprogClarification: Arguments vs. Input
	$ prog a1 a2
		"Two arguments. We're assuming the program knows how to handle this. The program can still read input from stdin, things you type."
	$ prog a1 a2 < file.txt
		"Whenever you want to read input, read from the file. Faucet of data is just waiting there."
	"I would highly recommend looking at diff, and what status codes it sets. Diff will set ${?} to 0 if different and 1 if not the same."

Recall:
	cout << stuff << endl; 		// endl is optional, it just adds a new line
	C++ provides three I/O stream objects
		cout: print to stdout
		cin: reads from stdin
		cerr: prints to stderr

I/O Operators
	<<: output operator, "put to" operator
	>>: input operator, "get from" operator

	e.g.
		cout << x; // put x to stdout
		cin >> y; // get from stdin into y
		cerr << z; // put z to stderr

		"The arrow is in the direction of information flow."
		*Keep the stream object on the right?

intro/plus.cc
	Read 2 numbers and add them.

#include <iostream>
using namespace std;
// Won't write the above two lines any more.

int main () {
	int x, y; // two int vars
	cin >> x >> y;
	cout << x + y << endl;
}

// Whitespace delimits strings from stdin. "./plus" then "4 5" is sufficient.
// ./plus, 4 five --> 4
//		y is not necessarily set to zero, it is a garbage stack location

cin is waiting for input, ignoring whitespace.
If a read fails, the program will move on! This is troubling.
	Scary that there is no indication of failed read.
	If a read fils then cin.fail() is true.
	If a read fails due to end of input then both cin.fail() and cin.eof() are true.

e.g. Read all integers from stdin and print them, one per line, on stdout. Stop if a non-integer or EOF is encountered.
lectures/io/readInts.cc

int main () {
	int i;
	while (true) {
		cin >> i;
		if (cin.fail()) break;
		// come here only if read is successful
		cout << i << endl;
	}
}

./a.out:
3
3
4
1 2 3 4
5
2
five
^ program terminates here when these characters are encountered.

CTRL-D or CTRL-C will also terminate. cin.fail() and cin.eof() flags will both be raised if we do that.

There is an implicit conversion from cin to void*. "A pointer with no type, or a pointer that can point to anything."
	"cin is a stream object of type istream"
	void* is a pointer to anything. It's key here that we can treat something as a pointer.
	A pointer is a numeric quantity
	if (cin) // true if !cin.fail(), false otherwise

	Now we can do "if (!cin) break;"

We have said that >> is the input operator.
In C/C++, >> is the right bit shift operator;
	a>>3; // 10101 >> 3 = 00010 (21 -> 2) (divides by 2^3)
These operators are overloaded.
	a>>3; vs cin>>y; have different meanings.
	Compiler checks left hand side
	LHS: int
		treats >> as bit shift operator
		result: int
	LHS: istream
		treats >> as input operator
		result: cin (an istream)
		This is useful for using multiple operators in series.
			cin >> x >> y
			Here, "cin >> x" results in a cin object (and in x having a value)
				This becomes "cin >> y", which results in cin; which ends.
		This is called casdading.
			We've already taken advantage of this, e.g. "cout << i << endl"
		You can cascade as many times as you want.
			cin >> x >> y >> z >> a;
				If cin fails early on, all subsequent reads fail.
	We can combine 2 lines in readInts.cc:
	if (!(cin >> i)) break; // "cin >> i" mutates i and evaluates to cin, which evaluates to binary based on whether the read was successful.

Rewriting readInts.cc (readInts4.cc):

int main () {
	int i;
	while (cin >> i) {  // Works if we only care about reads failing. Does not check for EOF. BE ABLE TO EXPLAIN THIS ON THE MIDTERM! (produces cin, converts to void*)
		cout << i << endl;
	}
}

e.g. Read all ints and echo them to stdout. Skip non-integers. Terminate at EOF.
	(Can't use simplified code above, since we need to distinguish _why_ the read fails.)

int main () {
	int i;
	while (true) {
		if (!(cin >> i)) { // something failed, this is the fail block
			if (cin.eof()) break; //done
			else { // bad read (received a non-integer)
				// for non-integer reads, we could:
				//		a) do nothing (but this will loop infinitely, because the fail flag will still be raised (cin.fail() is true)! )
				// 			recall: "once a read fails, all subsequent reads fail"
				// 		b) clear the flag: cin.clear();
				// 			if we only do this, we loop forever because that bad input is still there, even though the fail flag is cleared
				// 		c) ignore the bad input: cin.ignore();
				// 			This works! :)
				cin.clear();
				cin.ignore();
				// (!(cin >> i)) continues successfully now.
			}
		} else {
			cout << i << endl;
		}
	}
}

"You will be tested on these technical details on the midterm."I missed this lecture.
The following is transcribed from Anna Lorimer's Written Notes
--------------------------------------------------------------
Lecture 7: Streams

C++ Provides a string type: std::string
	Available in io/readstrings:


	#include <iostream>
	#include <string>

	int main () {
		string s; // you only have to change the type
		cin >> s;
		cout << s << endl;
	}


	*cin reads until whitespace

If you want to read in an entire line, use getline:
	getline(cin, s); // s is a string variable
		This reads until newline

In C you would use scanf with format specifiers.
	You don't need format specifiers in C++ (%s string, etc.)

How would you format cout? I/O Manipulators.
	e.g. cout << hex << i;
		hex is an i/o manipulator that prints i in hexadecimal
		This works by sending hex to cout. Nothing is printed but it changes how cout behaves by telling cout to set itself to hexadecimal.
		You have to reset cout after if you no longer want hex.
			e.g. cout << dec; // changes hex to decimal

There are lots of I/O manipulators:
	Look at <iomanip> header
	e.g. Left and right precisions (justifications)

Stream abstraction works for other sources of data.
	How to read from a file:


	#include <fstream>  // gives you access to ifstream (read) and ofstream (write)
	#include <iostream>
	using namespace std;

	int main () {
		ifstream f("suite.txt"); // here "ifstream" is the type, "f" is the name of the variable *cough*OBJECT*cough*, and "suite.txt" is the initialization.
		string s;
		while (f >> s) {  // while read is successful
			cout << s << endl;
		}
	}


	Anything you can do with cin (i.e. istream), you can do with a variable (f) of type istream.
		Same for cout and ofstream.

	You can treat a string as the source of input (input string).
	You can also write to a string.
		Include <sstream> which gives you istringstream (input) and ostringstream (output)

	Example: buildstring.cc

	
	int low = ...;  // constant string
	int high = ...;
	ostringstream ss;
	ss << "Enter a number between" << low << "and" << high << endl
	string s = ss.str(); // extract a string out of ostringstream
	cout << s;


	This is useful for converting a string to a number.


	getnum.cc:


	#include <iostream>
	#include <string>
	#include <sstream>
	using namespace std;

	int main () {
		int n;
		while (true) {
			string s;
			cout << "Enter a number:" << endl;
			cin >> s;
			istringstream ss(s);
			if (ss >> n) break;  // read int from ss

			cout << "That's not a number! Try again:" << endl;
		}
		cout << "You entered " << n << endl;
	}


	Look at readints5.cc and readintsSS.c, they do the same thing.

	*The only time reading in a string fails is EOF.

Strings
	In C we don't have strings, we have NULL-terminated character arrays.
		This is annoying, namely the fixed size thing.
		You might accidentally overwrite the null terminator.
	C++ also has no built in strings, but provides string type.
		This grows and shrinks as needed.

		Example: string s = "Hello"; // type of s is stdstring, type of "Hello" is a C-style string (i.e. a character array that is NULL-terminated)
		*You're assigning a C-style string to a C++ string -> should give a compiler error!
		C++ has a special feature which converts a C-style string to a C++ string (they are NOT the same).

---------------- In C ---- vs. -- In C++ ---
Equality      | strcmp()      | s1 == s2
              |               |
Inequality    | strcmp()      | s1 != s2
              |               |
Comparisons   | strcmp()      | <, >, ==
              |               |
Length        | strlen()      | s.length()
              |               |
Concatenation | strcat()      | s = s1 + s2
--------------------------------------------

In C you can directly access individual characters in a string.
	You can still do this in C++ (individual access)
	This is done with overloading square brackets [].
	Example:
		std::strings = ...;
		s[0], s[1], ... are accessibleAssorted Goodies
Default Arguments
	void printSuiteFile(string filename = "mytests.txt") {
		ifstream myfile(filename.c_str()); // ifstream arg must be a 'C-style string', not string object. (won't compile if only calling with 'filename')
		string s;
		while (myfile >> s) {
			cout << s << endl;
		}
	}

You can get a c style string from std::string using the following:
	filename.c_str();

printSuiteFile(); // use the default value
printSuiteFile("suite.txt"); // use the specified arg

Optional arguments must appear last!
A default argument cannot be followed by a non-default argument.

void testParams(int num=0, string city="Waterloo")

testParams(5, "Toronto"); // legal
testParams(5); // legal
testParams(); // legal
testParams("Montreal"); // not legal
testParams( , "Montreal"); // not legal
*Can't assign city="Montreal" while calling, as in Python

Overloading (Function Overloading)
------------------------------------
int negate (int a) {
	return -a;
}
bool negate (bool a) {
	return !a;
}
-----------------------// in c, this won't compile! Functions must have a unique name.

In C++, this works. We have overloaded the negate function.
The C++ compiler looks at the name of the function, number of arguments, and types of arguments.
"What identifies a function is not only its name, but its argument types."

Function Header (Signature)
	In C++: name + types of arguments

In C++, you cannot have two functions that only differ in their return type.

Recall: '<<' operator
	Actually implemented in C++ as a function:
		____ operator<<( , ) { ... }
		int operator<<(int, int) { ... } // returns int
		istream operator<<(istream, int) { ... } // returns istream "not exactly correct, but we'll get to why soon"
		ostream operator<<(ostream, string) { ... } // returns ostream
		"Perfect example of overloading in C++"
		"Compiler will keep a list of the different function headers"
		"Well documented in <iostream> stdlib"

Declaration Before Use
	In C, we cannot use something before it's declared.
	Same in C++.
		This is problematic for mutual recursion (where two functions are calling each other).

	Look at:
	functions/forwardBad.cc
		Won't compile, because "odd was not declared in this scope".
		To fix this, forward-declare the odd function (header only).
	functions/forwardGood.cc
		bool odd(unsigned int n); // forward declaration (doesn't define the function, but says that it exists).

	forwardBad.cc does not compile because odd is used before it is declared.
	To avoid this, add a forward declaration for odd.
	Saying to the compiler: 'Trust me, you will see a function with this signature.'
		*You can place default arguments in forward declarations.

	Declaration before use, NOT definition before use.
		A declaration is simply an assertion that something exists.
		A definition is the actual implementation.
		*You can declare something as many times as you want, but you can define it only once.
			(There is no benefit to doing multiple declarations, this is just a technicality)

Pointers
	int n = 5;
	int *p = &n; // p is set to the address of n
	cout << p; // prints 10000 (in hex)
	cout << *p; // prints the contents of the thing p points to

	int **pp; // declare a pointer to a pointer to an int
	pp = &p; // 48000
	**pp = 10; // dereferences address 48000 and then 10000. 5 mutates to 10.
		*if(pp) is only false if it doesn't point to an address, is 0 or NULL
__________________
|ADDRESS | STACK |
-----------------|
|        |       |
|10000  n| 5     |
|        |       |
|        |       |
|        |       |
|48000  p| 10000 |
|        |       |
|        |       |
|        |       |
|      pp| 48000 |
|        |       |
|        |       | 
------------------

Arrays
	int a[] = { 1, 2, 4, 8 };
	An array is not a pointer!
	The name of the array is shorthand for the address of the first element of the array.
	a == &a[0]
	*a == a[0]
	*(a + 1) == a[1] // '+' operator accounts for size of typeof(a)
		Recall that this is called "pointer arithmetic"

Structs
	In C:
	struct Node {
		int data;
		struct Node * next; // You don't need to write 'struct' here in C++ (leaving it in is okay, because backwards compatible)
	}; // Don't forget the semicolon! You can technically declare global variables of Node (n1, n2, etc.) before the semicolon, so it is needed!

	In C++:
	struct Node {
		int data;
		Node next;
	}; // Won't compile. ("Can I determine the size of this node in order to allocate memory? Nope. Four bytes plus size of a Node...")
	This worked before, because pointers had a fixed size.

Constants
	const int maxGrade = 100; // Told the compiler that maxGrade has value 100 and it won't change.

	Rule: a const definition must be initialized (can't just say 'const int maxGrade;') "Must be defined when you declare it."

	Constants of other types can also be defined:
	const Node n = {5, NULL}
		Cannot change n. n.data = 10; // Won't work.

	int n = 5;
	const int *p = &n; // p is a pointer to a constant int. [a const-int, haha -JR]
	*I can change p if I want. p=&m; // p is not a constant pointer
	*I cannot, however, use p to change n. *p = 7; // Won't work.
	*I can still directly change n. n = 10; // Works.
	Read backwards: "p is a pointer to an int constant"
	
	int * cons p = &n;
	"p is a constant pointer to an integer"
	*Now, I can't do p = &m;
	*Can do *p = 20;

	const int * const p = &n;
	*Can't do p = &m;
	*Can't do *p = 10;
	*Can still change n directly if it wasn't declared as constant.

Parameter Passing **5-10% QUESTION ON MIDTERM
	void increment(int n) {
		n+=1;
	}
	int x=5;
	increment(x);
	cout << x; // prints 5

	Pass by value: a copy of x was created!

	void increment(int *n) {
		*n += 1;
	}
	int x=5;
	increment(&x); // send the address of x
	cout << x; // prints 6.

	*Note that these also count as overloaded functions.

Cliffhanger for next time:
	scanf("%d", &i); // read an int into variable i
	We gave the address of i.
	cin >> i; // reads in a value at i
	These functions are operators (operator>>(istream, int))
	Why can I pass it i, not &i?
	Why not do cin >> (&i); // ?

	"Pass by reference!"Recall cliffhanger from last time:
	scanf("%d", &i);
	cin >> i; // why does this work? (It's not being sent the address of the variable, just the name of the variable)
	Why not use "cin >> (&i);" ?

C++ provides another pointer-like type: References
	int y = 10;
	int &z = y; // z is a reference to y (in C++). Do NOT read this as "the address of z equals y", say "z is a reference to y".

	A reference is like a constant pointer with automatic dereferencing.
		z will always point to y.
		We can write: z = 15; // changes the value of y
			This sets y to 15.
			We no longer have to do *z = 15; // illegal in C++
			No star is needed because it will ALWAYS be automatically dereferenced.

	int *p = &z; // sets p to the address of y
		We set p to the address of z, but since z is a reference to y, we got the address of y.
		A reference has no identity of its own. We tried to assign it a value or get its address, but got y each time.
			It is another name for y.
			Or we can say z is an alias for y.
		Even doing sizeof(z) doesn't always return 4 bytes as expected in C, but the size of y.

	Rules of references:
		1. We cannot leave references uninitialized.
			int &x; // can't do this, since constants/references must be initialized

		2. A reference must be initialized to something that has an address.
			Things that have an address are called 'Lvalues' (this is a compiler term).
			int &x = 5; // can't do this, because 5 is not really an address but a literal value.
			int &y = a + b; // can't do this either, because an expression doesn't technically have an address.

		3. We cannot create a pointer to a reference.
			int &*x = ...; // doesn't work (at least not in the g++ standard)

			3a. We can, however, create a reference to a pointer.
				int *&x = ...; // works

		4. We cannot create a reference to a reference.
			int &&x = ...; // not allowed

			Note: we can still do *p = &z; // sets p to the address of what z is referencing

		5. We cannot create an array of references.
			int &x[3] = {1, 2, 3}; // not allowed
				The name of an array is a pointer to the first address of the array, but &*a is disallowed.

	Use references in function parameters.
		Recall this code from last class:
			void inc (int *n) {
				*n += 1;
			}
			int x = 5;
			inc(&x);
			cout << x; // 6

		Now we will do this with references:
			void inc(int &n) {
				n += 1;
			}
			int x = 5;
			inc(x);
			cout << x; // 6

			In this code, x is being passed by reference. Anything we do to n is actually being done to x.

		Note: We could have a reference to a function (like how we can have a constant pointer to a function).

	Why does "cin >> x" work?
		x is passed as a reference.

		Let's look at the function header for the input operator:
			istream &operator>>(istream &in, int &data) {
				// type of cin is a reference to an istream.
				// "int &data" is the right hand side, it takes the argument by reference.
				// "istream &in", the left hand side, is also being passed by reference. This is so that we can set error flags on "&in" (cin)
				// the reasoning for the return value of "istream &" is so that we aren't returning a copy istream, but rather a reference to the original istream (so it can be chained into another expression)
				// in C, we would have to do all of this with pointers. Automatic dereferencing is the main advantage here.
			}

Suppose I have a struct:
	struct ReallyBig {
		...;
	};
	int f (ReallyBig rb) { ... }
	f(x); // what happens here?

	A copy of x is going to be made.
		(-) This is expensive to do.
		(-) Also, the changes to rb are not visible to the caller (the piece of code that called f)

	In C, we would send a pointer to ReallyBig.
		(+) This suppresses the copy.
		(+) And changes made in the function are visible to the caller.

	(Passing by Reference vs Passing by Value)

	In C++:
		int g (ReallyBig &rb) { ... }
		g(x);
			(+) This suppresses the copy.
			(+) Changes to rb are visible to the caller.
			(+) Automatic dereferencing.

	What if we want to suppress the copy but we don't want changes made to ReallyBig.
	Send it as a constant reference.
		int h (const ReallyBig &rb) { ... }
		ReallyBig x;
		h(x); // x is passed by reference (no copy is made, so this is efficient), but also can't be modified by h.
		// It's like you only have a read permission, but not a write permission.

	Note: This can be applied to struct Node, struct llist, etc. (The various data structures from CS136)
	Advice: Use pass by const reference for anything bigger than an int.
		int f (int &n) { ... }
		int g (const int &n) { ... }
		f(5); // trying to pass 5 by a reference, but this is illegal because 5 doesn't have an address (5 is not an Lvalue).
			f(y + y); // also doesn't work
		g(5); // compiler WILL allow this, because it is a const and can be stored conveniently. Compiler will remember 5 as long as you don't want to change it.
			g( y + y); // also works, for the same reason (as opposed to doing "int z = y + y; f(z);" every time).


Note: References can't be NULL (we will get back to this in 2 weeks)
"References are not the easiest thing to understand, go over this material and get good at using references." - NN


Dynamic Memory
	In C,
		int size = ...; // size of an array
		int *p = malloc(size * sizeof(int))
		free(p);
	
	Things are not a whole lot better in C++, but we don't have to do the "size * sizeof(int)" calculation.
	C++ Does support malloc() and free(), but DON'T use it (disallowed in this course)!
		instead, use 'new' and 'delete'

		In the linked list example (in C):
			struct Node {
				int data;
				Node *next;
			}

		Let's dynamically create a node, in C++:
			Node *np = new Node;

		'new' is type-aware.
			We don't need to compute the amount of memory we want.
			This is less error-prone. With 'new', you will always get enough memory (or you can receive an error, which we will come back to later).

		When you are done with the node:
			delete np;

		"Do not mix malloc/free with new/delete, that is the worst thing that you can do! Bad things happen. Don't do it. This is what happens when you combine C/C++ codebases." - NN
			delete looks at a book-keeping table that is only updated by new, so it can't recognize malloc'ed things.

	Dynamic Arrays
		Suppose I read in a number and create an array of that size:
			cin >> n;
			int *arr = new int[n]; // dynamically allocated array of size n! new is smart enough to do this!
			// You just tell n that you want n integers, and it uses its type-aware magic to calculate and allocate enough memory.

		Once you are done:
			delete [] arr; // a lot of people forget the '[]', then bad things happen.

			"Some course notes say that 'delete arr' would just delete the first element of the array. This is nonsense, it's really an undefined thing that is compiler-specific. Just remember the '[]'" -NN

		If you allocated memory, it is still your job to deallocate it.

		"And did I mention, don't forget the '[]'!" - NN

		Q: Can you delete something by reference?
		A: "Not sure, don't hold me to this, but I think that would work." - NN

Stack vs Heap Allocation (This should be review)
	You have access to some memory, which is divided into three things:
		program
		stack
		heap

		-----------
		| Program |
		-----------
		| Heap \/ |
		|      \/ |
		|      \/ |
		|      \/ |
		|         |
		|grows dwn|
		-----------
		| Stack ^ |
		|grows up |
		-----------

	Local Variables:
		Allocated on the stack.
		Stack space is reclaimed when local var goes out of scope (a function returns, etc. and the function's local vars are freed).

		Node n; // n is local variable on the stack
		Node *np = new Node; // new Node is on the heap (dynamically allocated) but *np is local, on the stack.

		    ...
		|         |
		| Node    |
		|         |
		|         |   (heap)
		-----------
		| np      |   (stack)
		| n       |
		-----------

	Heap-allocated data continues to live even when the pointer goes out of scope.
		That is a memory leak!
		(stack allocated local var of a heap-allocated value goes out of scope when, say, the function that assigned the var returns)